<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>迭代器与生成器</title>
    <script>

        /*
        一、理解迭代
            1) for 循环
            for (let i = 0; i < 10; i++) {
                console.log(i);}

            缺点：需要事先知道数组长度，不适用于其他数据结构，不通用

            2) Array.prototype.forEach()

            let collection = ["you", "yoh", "yeah", "yep"];
            collection.forEach((item) => console.log(item));

            缺点：无法标识迭代何时中止，仍然不够通用

        二、迭代器模式

            2.1 可迭代协议（Iterable 接口）
            1) 很多内置类型如字符串、数组、映射、集合、arguments 对象、NodeList 等都实现了 Iterable 接口
            以 Symbol.iterator 为属性名，以迭代器工厂方法为属性值

            let num = 1; //未实现 Iterable 接口的类型
            let array = [1, 2, 3, 4]; //实现 Iterable 接口的类型

            console.log(num[Symbol.iterator]); //undefined，未实现迭代器工厂函数
            console.log(array[Symbol.iterator]); //ƒ values() { [native code] }，实现了迭代器工厂函数

            console.log(num[Symbol.iterator]()); //报错
            console.log(array[Symbol.iterator]()); //Array Iterator

            2) 所有实现 Iterable 接口的类型都会根据如下的语言特性自动调用工厂函数生成迭代器对象，不需要显式调用
            for-of 循环
            数组解构
            扩展操作符
            Array.from()
            创建集合
            创建映射
            Promise.all()接收由期约组成的可迭代对象
            Promise.race()接收由期约组成的可迭代对象
            yield* 操作符

            3) 迭代器

            let arr = [1, 2, 3]; //可迭代对象
            let iter = arr[Symbol.iterator](); //调用迭代器工厂函数，创建一个迭代器对象
            console.log(iter.next()); //{done: false, value = 1} //每调用一次 next() 方法，返回一个 IteratorResult 对象
            console.log(iter.next()); //{done: false, value = 2} //对象中包含是否达到末尾的 done 属性和可迭代对象的一个值 value
            console.log(iter.next()); //{done: false, value = 3}
            console.log(iter.next()); //{done: true, value = undefined} //达到末尾后 done 为 true，value 为 undefined
            console.log(iter.next()); //{done: true, value = undefined}

            4) 自定义迭代器
            在类中自定义 [Symbol.iterator]() 工厂函数 和 next() 方法，其对象成为可迭代对象

            class myArray {
            constructor() {}

            [Symbol.iterator]() {
                let count = 1; //计数器放在闭包里
                return {
                    next() {
                        if (count < 10) {
                            return {done: false, value: count++;}
                        } else {
                            return {done: true, value: undefined;}}}};}}

            5) 提前中止迭代器
            可选的 return() 方法指定迭代器提前关闭时执行的逻辑
            迭代器可能发生提前关闭的情况
                通过 break、continue、return 或 throw 退出 for-of 循环
                解构操作并未消费所有值

            return() 方法必须返回一个有效的 IteratorResult 对象，最简单如 {done: true}

            [Symbol.iterator]() {
                let count = 1; //计数器放在闭包里
                return {
                    next() {
                        ......
                    },
                    return() { //可选的 return() 方法在迭代器提前关闭时生效
                        console.log("Exiting eraly");
                        return {done: true};}};}
        三、生成器
        拥有在一个函数块内暂停和恢复代码执行的能力

        3.1 生成器基础
        生成器是一个函数，可以定义函数的地方就可以定义生成器。
        在函数名称前加 * 代表是生成器

         //生成器函数声明
        function* generatorFn() {
        }
        //生成器函数表达式
        let generatorFn = function* () {
        }
        //生成器函数作为对象字面量的方法
        let foo = {
            * generatorFn() {
            }
        }
        //生成器函数作为类的实例方法
        class Foo {
            * generatorFn() {
            }
        }
        //生成器函数作为类的静态方法
        class Foo {
            static* generatorFn() {
            }
        }

        调用生成器函数会创建一个处于暂停状态的生成器对象，调用 next() 方法让生成器对象开始或恢复执行
        生成器函数的返回值是 next() 方法中 value 属性值

        3.2 yield 中断执行
        yield 让生成器暂停执行，done 为 false，必须直接位于生成器函数内部
        return 让生成器停止执行，done 为 true

        function* generatorFn() {
            yield "hello";
            yield "yoh";
            return "good";
        }
        let generatorObject = generatorFn();
        console.log(generatorObject.next()); // { done: false, value: "hello" }
        console.log(generatorObject.next()); // { done: false, value: "yoh" }
        console.log(generatorObject.next()); // { done: true, value: "good" }

        yield* 增强 yield 行为，遍历可迭代对象，一次输出一个值
        yield* [1,2,3] <=> for(const x of [1,2,3]){yield x;)

        3.3 提前中止生成器
        return()


        */



    </script>
</head>
<body>

</body>
</html>