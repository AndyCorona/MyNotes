<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>概念解析</title>
    <script>


        /*


异步任务的执行机制是：

当主线程遇到一个异步任务，比如一个ajax请求，当主线程执行到xhr.send()的时候，这个send命令是立即执行的，并不会像一些人想象的，拖到所有同步任务的最后面。
然后主线程向http线程发送指令，要求http线程向服务器发送请求。这里强调一下http线程，显然它不是主线程的一部分，因为它可以并发，如果你有100个ajax请求，每个都需要1秒钟，是不是http线程要花100秒呢？并不是，它会并发100个请求，总共耗时大约1.01秒就完成了。

主线程向以http线程为代表的几个线程发送指令之后，主线程就暂时不再管这个ajax任务了，而是去看任务队列里的下一个任务。

http线程发送了请求之后接收反馈，收到之后，形成一个新的事件（可以叫做“我收到啦！”事件），然后插入到回调函数队列中，
因为回调函数队列的优先级很低，所以会排到总队列的最后面，其结果就是：主线程把同步任务都完成了，才开始执行异步事件的回调。注意，并不是异步任务在全体同步任务结束之后才开始，
而是异步任务的回调通常在全体同步任务结束之后才开始！异步任务跟异步任务的回调是两回事！是两个任务！一个鲜明的例子就是setTimeout(fn, 1000)，计时是从主线程遇到setTimeout()任务，
然后分配给计时器线程，计时器线程开始干活的时候就开始计时了！只不过要1秒之后fn才执行！setTimeout()和fn是两个任务！setTimeout()是立即执行，fn才是1秒之后执行。但是setTimeout()的执行，
人眼是感受不到的，因为并没有什么地方有一个秒表告诉你setTimeout()开始执行了；而fn的执行，人眼能感受到，所以人们会错误的以为fn才是异步任务，其实fn并不是，fn是个回调任务，往往fn是同步任务，比如fn可能是console.log(123)，这怎么会是异步任务。

所以，异步机制是浏览器的两个或以上常驻线程共同完成的，异步请求是JS主线程和其他某个线程共同完成的，JS的执行线程发起异步请求（这时浏览器会开一条新的HTTP请求线程来执行请求，这时JS自己的任务已完成，
继续执行线程队列中剩下的其他任务），然后在未来的某一时刻"任务队列"线程监视到之前的发起的HTTP请求已完成，"任务队列"就会把完成事件插入到JS执行队列的尾部等待JS处理。




        */


    </script>
</head>
<body>

</body>
</html>