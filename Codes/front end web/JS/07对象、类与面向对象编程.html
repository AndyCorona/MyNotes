<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>对象、类与面向对象编程</title>
    <script>
        /*
        一、理解对象
        对象是一组属性的无序集合。每个属性或方法都由一个名称来标识，这个名称映射到一个值

            1.1 属性的类型
            ECMA-262 使用一些内部属性来描述属性的特征，用两层中括号标识内部属性（[[Enumerable]]），开发者不能直接访问这些内部属性
            1)数据属性
            数据属性包含一个保存（读写）属性值的位置。有 4 个内部属性描述数据属性的行为
                [[Configurable]]
                    表示数据属性是否可以通过 delete 删除并重新定义，是否可以修改其内部属性，是否可以改为访问器属性，默认值为 true
                [[Enumerable]]
                    表示数据属性是否可以通过 for-in 循环返回，默认值为 true
                [[Writable]]
                    表示数据属性的值是否可以修改，默认值为 true
                [[Value]]
                    包含数据属性的实际值，即读写属性值的位置

                let person = {name: "Andy";} //创建一个名为 name 的数据属性，赋予一个值 "Andy"。

            通过 Object.defineProperty() 方法精确调控属性的内部属性，但 [[Configurable]]、 [[Enumerable]]、 [[Writable]] 默认值为 false

            let person = {}
            Object.defineProperty(person, "name", {
                writable: false, //name 属性值不可再被修改
                value: "Andy"
            })
            console.log(person.name); //"Andy"
            person.name = "Merry"; //修改无效
            console.log(person.name); //"Andy"

            属性的内部属性 [[Configurable]] 被显式设置为 false 后，除了 [[writable]] 内部属性可以修改，其他内部属性不能再被修改，包括 [[Configurable]] 自身

            2) 访问器属性
            访问器属性不包括数据值，不能直接定义，只能通过 Object.defineProperty() 方法定义，有 4 个内部属性描述访问器属性的行为
            [[Configurable]]
                表示访问器属性是否可以通过 delete 删除并重新定义，是否可以修改其内部属性，是否可以改为数据属性，默认值为 false
            [[Enumerable]]
                表示访问器属性是否可以通过 for-in 循环返回，默认值为 false
            [[Get]]
                 获取函数，在读取属性时调用，默认值为 undefined
            [[Set]]
                设置函数，在写入属性时调用，默认值为 undefined

            let book = {
                year_: 2017, //数据属性
                edition: 1 //数据属性
            };
            Object.defineProperty(book, "num", { //num 为访问器属性
                get() {
                    return this.year_; //获取访问器属性 num 的值时，返回数据属性 year_ 的值
                },
                set(newValue) {
                    if (newValue > 2017) {
                        this.year_ = newValue; //设置访问器属性 num 的值时，改变数据属性 year_ 和 edition 的值
                        this.edition += newValue - 2017;
                    }}});
            book.num = 2018;
            console.log(book.year_); //2018
            console.log(book.edition); //2

            1.2 定义多个属性
            Object.defineProperties() 方法可以同时定义多个数据属性和访问器属性，但 [[Configurable]]、 [[Enumerable]]、 [[Writable]] 默认值为 false

            let book = {};
            Object.defineProperties(book, {
                year_: {value: 2017},
                edition: {value: 1},
                num: {
                    get() {
                        return this.year_;
                    },
                    set(newValue) {
                        if (newValue > 2017) {
                            this.year_ = newValue;
                            this.edition += newValue - 2017;
                        }}}});

            1.3 读取属性的内部属性
            Object.getOwnPropertyDescriptor() 或 Object.getOwnPropertyDescriptors()

            console.log(Object.getOwnPropertyDescriptor(book, "year_")); //返回一个对象中指定某个属性的所有内部属性值
            //{
            //    configurable: false,
            //    enumerable: false,
            //    value: 2017,
            //    writable: false
            //}

            console.log(Object.getOwnPropertyDescriptors(book)); //调用每个属性的 etOwnPropertyDescriptor() 方法，返回一个对象中所有属性的所有内部属性值
            //{
            //    edition: {
            //        value: 1,
            //        writable: false,
            //        enumerable: false,
            //        configurable: false
            //    },
            //    num: {
            //        enumerable: false,
            //        configurable: false,
            //        get: ƒ,
            //        set: ƒ
            //    },
            //    year_: {
            //        value: 2017,
            //        writable: false,
            //        enumerable: false,
            //        configurable: false
            //    }
            //}

            1.4 合并对象
            Object.assign() 将源对象的以字符串和符号为键的属性浅复制给目标对象

            const target = {};
            const source = {name: "Andy"};
            let returnObject = Object.assign(target, source); //修改 target 对象并返回修改后的 target 对象
            console.log(returnObject === target); //true
            console.log(target === source); //false

            1.5 对象相等判断
            新增的 Object.is() 和全等（===）很像，但对一些特殊情况的比较更友好

            console.log(NaN === NaN); //false
            console.log({} === {}); //false
            console.log(Object.is(NaN, NaN)); //true
            console.log(Object.is({}, {})); //false

            1.6 增强的对象语法
            语法糖，没有改变现有引擎的行为，但极大地方便了处理任何类的对象
            1) 属性值简写
            若变量名和属性名相同，只写属性名，属性值可自动解析为同名变量的值

            const name = "Andy";                   <=>     const name = "Andy";
            const person = {name: name};           <=>     const person = {name}; //只写属性名，不写属性值
            console.log(person.name); //"Andy"     <=>     console.log(person.name); //"Andy"

            2) 可计算属性
            [] 包含的 JavaScript 表达式作为属性
            class job {};

            let person = {
                ["name".toUpperCase()]: "Andy",
                ["ag" + "e"]: 27,
                [job]: "IT"}

            3) 简写方法名
            在对象中定义方法时，原先的“方法名: function(形参列表)”可简写成“方法名(形参列表)”

            let person = {                                  <=>     let person = {
                sayName: function (name) {                  <=>         sayName (name) {
                    console.log(`My name is ${name}`);}}    <=>             console.log(`My name is ${name}`);}}
            person.sayName("Andy"); //"My name is Andy"     <=>     person.sayName("Andy"); //"My name is Andy"

            4) 访问器 Getter 和 Setter
            在对象中定义访问器属性的 get 和 set() 方法

            const person = {
                name: "Andy", //无法为真实的属性定义 Getter 和 Setter
                get decName() {return this.name;}, //设置访问器属性 decName 的 Getter，当获取 decName 属性值时，返回 name 属性值
                set decName(value) {this.name = value;}, //设置访问器属性 decName 的 Setter，当设置 decName 属性值时，改变 name 属性值
            }
            console.log(person.decName); //"Andy"
            person.decName = "Jane";
            console.log(person.name); //"Jane"
            console.log(person.decName); //"Jane"

            1.7 对象解构
            let person = {name: "Andy", age: 28};

            let {name: personName, age, job = "IT"} = person; //对象解构，有 let|var|const 关键字则不加 ()
            console.log(personName); //找到同名 name 属性，将 "Andy" 赋给 personName
            console.log(age); //找到同名 age 属性，将 28 赋给 age
            console.log(job); //源对象没有 job 属性，在目标对象中可定义默认值

            let copyPerson = {};
            ({name: copyPerson.name, age: copyPerson.age, job: copyPerson.job} = person); //对象解构，无 let|var|const 关键字则加 ()
            console.log(copyPerson); //{age: 28, job: undefined, name: "Andy"}

        二、创建对象
        对象在代码执行过程中的任何时候都可以被创建和增强，具有极大的动态性

            2.1 工厂方法
            工厂模式就是一个简单的函数，这个函数可以创建对象，为它添加属性和方法，然后返回这个对象（都是 Object 类型）

            function createPerson(name, age, job) {
                let o = new Object();
                o.name = name;
                o.age = age;
                o.job = job;
                o.sayName = function () {
                    console.log(this.name);
                }
                return o;
            }

            let person1 = createPerson("Andy", 28, "EE");
            let person2 = createPerson("Jane", 27, "QA");

            2.2 构造函数
            构造函数创建的对象可以表示为特定类型，但通过构造函数创建的每个对象都会创建各自的方法（函数），无法共享
            new 关键字在后台进行如下操作：
            1) 在内存中创建一个新对象
            2) 这个新对象内部的 [[Prototype]] 内部属性指向构造函数的 prototype 属性
            3) 构造函数内部 this 指向新对象
            4) 执行构造函数内部的代码
            5) 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象

            function Person(name, age, job) {
                this.name = name;
                this.age = age;
                this.job = job;
                this.sayName = function () {
                    console.log(this.name);
                };
            }

            let person1 = new Person("Andy", 28, "EE");
            let person2 = new Person("Jane", 27, "QA");

            2.3 原型模式
            1) 每个函数都会创建一个 prototype 属性，指向一个系统创建的对象，这个对象称为原型对象。
            原型对象里可以包含需要共享的属性和方法，且所有原型对象一定有一个 constructor 属性，指向此函数。
            用构造函数创建的每个对象的内部属性 [[Prototype]]（无法访问）自动指向原型对象，每个对象暴露出 _proto_ 属性来访问原型对象

            function Person() {}; //创建构造函数
            Person.prototype.name = "Andy"; //在其原型对象添加共享的属性
            Person.prototype.age = 28;
            Person.prototype.job = "EE";
            Person.prototype.sayName = function () { //在其原型对象添加共享的方法
                console.log(this.name);}
            let person1 = new Person(); //创建对象
            let person2 = new Person();
            console.log(person1.name); //"Andy"，两个对象共享原型对象的 name 属性
            console.log(person2.name); //"Andy"
            console.log(person1.sayName() == person2.sayName()); //true，两个对象共享原型对象的 sayName() 方法

            function Person() {}; //创建函数，没有任何共享属性和方法的构造函数
            console.log(Person.prototype); // 原型对象，{ constructor: f Person(), __proto__: Object }
            console.log(Person.prototype.constructor); //ƒ Person() {}，原型对象的 constructor 属性指回 Person 函数
            console.log(Person.prototype.constructor === Person); //true

            console.log(Person.prototype.__proto__ === Object.prototype); //true，正常原型链都会终止于 Object 原型对象
            console.log(Person.prototype.__proto__.constructor === Object); //true
            console.log(Object.prototype.__proto__); //null，Object 原型对象的原型对象为 null

            //构造函数、原型对象和对象是三个完全不同的对象
            let person1 = new Person();
            console.log(person1.__proto__ === person1); //false，
            console.log(person1.__proto__ === Person()); //false
            console.log(person1 === Person()); //false

            //instanceof 检查 person1 的原型链上是否包含 Person 的原型对象
            console.log(person1 instanceof Person); //true

            //isPrototypeOf() 方法会检查 Person 的原型对象是否为 person1 的原型对象
            console.log(Person.prototype.isPrototypeOf(person1)); //true

            //Object.getPrototypeOf() 可以很方便的获取一个对象的原型对象
            console.log(Object.getPrototypeOf(person1) == Person.prototype); //true

            //Object.creat() 可以创建一个新对象，并指定其原型对象
            let person3 = Object.create(Person.prototype);

            2) 原型层级
            当通过对象调用属性的方法时，搜索顺序类似作用域链。先搜索对象本身是否有对应的属性或方法，有则停止查找并返回。
            无则沿着指针进入该对象的原型对象查找，有则停止查找并返回，无则进入该对象的原型对象的原型对象查找。
            若一直找到 Object 原型对象也没找到，则返回 undefined（对于属性）或报错（对于方法）

            虽然对象可以读取其原型对象上的值，但无法修改，只能通过在对象上创建和原型对象同名的属性或方法，覆盖原型对象相应的值
            因为根据原型链搜索规则，在对象本身找到对应的属性或方法后，不会继续在其原型对象上查找

            function Person() {};
            Person.prototype.name = "Andy";
            Person.prototype.sayName = function () {console.log(this.name);}

            let person1 = new Person(); //创建对象，读取其原型对象上的值
            let person2 = new Person(); //创建对象，覆盖其原型对象上的值
            person2.name = "Jane"; //覆盖其原型对象的同名 name 属性
            person2.sayName = function () { //覆盖其原型对象的同名 sayName() 方法
                console.log("Override");
            }

            console.log(person1.name); //"Andy"，来自原型对象
            console.log(person2.name); //"Jane"，来自对象本身
            person1.sayName(); //"Andy"，来自原型对象
            person2.sayName(); //"Override"，来自对象本身

            person2.name = null; //将对象上的覆盖属性设置为 null 也无法取消其对原型对象的覆盖
            console.log(person2.name); //null

            //hasOwnProperty() 方法判断属性或方法是否在对象上而不是在原型对象上
            console.log(person1.hasOwnProperty("name")); //false，person1 的 name 属性定义在原型对象上
            console.log(person2.hasOwnProperty("name")); //true，person2 的 name 属性定义在 person2 自身

            delete person2.name; //只能通过 delete 完全删除，才能取消覆盖
            console.log(person2.name); //"Andy"
            console.log(person1.hasOwnProperty("name")); //false
            console.log(person2.hasOwnProperty("name")); //false

            3) in 操作符
            单独使用 in 操作符时，只要可以通过对象访问到指定属性，就返回 true

            console.log("name" in person1); //true，name 属性来自原型对象
            console.log("name" in person2); //true，name 属性来自对象本身
            console.log("hasOwnProperty" in person2); //true，hsOwnProperty 来自 Object 原型对象

            for-in 循环获取可通过对象访问可枚举的属性，包括对象自身属性及其原型对象上的属性
            Object.keys() 返回该对象自身的所有可枚举属性字符串数组，不包括其原型对象上的属性
            Object.getOwnPropertyNames() 返回该对象自身的所有属性（无论是否可以枚举）的字符串数组，不包括其原型对象上的属性

            4) 属性枚举顺序
            for-in 循环和 Object.keys() 枚举顺序不确定，取决于引擎
            Object.getOwnPropertyNames()、Object.getOwnPropertyNames() 和 Object.assign() 的枚举顺序确定

            2.4 对象迭代
            Object.values() 和 Object.entrien()

            let o = {name: "Andy", age: 28, job: "EE"}
            console.log(Object.values(o)); //Array(3) ["Andy", 28, "EE"]，返回对象值数组，会忽略符号属性
            console.log(Object.entries(o)); //Array(3) [["name","Andy"], ["age", 28], ["job", "EE"]]，返回对象键值对数组，会忽略符号属性

            2.5 重写原型对象
            通过 Object 构造函数重写原型对象覆盖初始自动生成的原型对象后，原型对象的 constructor 属性指向 Object，应手动改为对应的构造函数。
            因开发者定义的所有属性的内部属性都为 true，系统自动生成的所有属性的内部属性都为 false，所以应该把 constructor 属性的内部属性[[enumerable]] 改回 false

            function Person() {}; //函数一创建，就自动生成一个原型对象

            Person.prototype = { //重写原型对象，覆盖了初始自动生成的原型对象
                name: "Andy",
                age: 28,
                job: "EE",
                constructor: Person, //重写后的原型对象指向 Object，应手动改为 Person
                sayName() {console.log(this.name);}}

            Object.defineProperty(Person.prototype, "constructor", {
                enumerable: false, //手动指定的 constructor 属性的内部属性 [[enumerable]] 为 true，必须改为 false
                value: Person
            });

            2.6 原型的问题
            原型对象中的所有属性是共享的，包括引用值的属性。一个对象对引用值中的内容进行修改，会影响其他所有对象引用值属性中的内容

            function Person() {};
            Person.prototype.arr = []; //原型对象上的引用值属性，所有对象共享 arr 数组
            const person1 = new Person();
            person1.arr.push("person1"); //person1 改变数组内容
            const person2 = new Person();
            console.log(person2.arr); //["person1"]，person2 的数组内容也改变

        三、继承
        接口继承只继承方法签名，实现继承继承实际的方法。ECMAScript 中函数没有签名，所以只有实现继承

            3.1 原型链
            通过父类构造函数创建的一个对象充当子类的原型对象，形成一环原型链，实现继承
            但原型链仍存在原型对象的引用值属性中的内容被共享的问题，且子类在实例化时不能给父类的构造函数传参

            function SupType() {}; //父类
            SupType.prototype.name = "Andy";

            function SubType() {}; //子类
            SubType.prototype = new SupType(); //重写子类的原型对象
            SubType.prototype.age = 28;

            const subType = new SubType();
            console.log(subType.name); //子类对象拥有父类原型对象的属性和方法

            3.2 盗用构造函数
            在子类构造函数中调用父类构造函数，实现继承
            盗用构造函数解决了原型链存在的问题，子类实例化可以向父类的构造器函数传参
            但子类无法访问父类原型对象的属性和方法，且构造器函数中定义的方法不能重用

            function SupType(arr) {this.arr = arr;}; //父类构造函数
            function SubType() {SupType.call(this, [1, 2, 3, 4]);}; //子类构造函数中调用父类构造函数

            const subType = new SubType(); //创建子类对象，会调用父类构造函数，执行父类构造函数中的所有初始化代码
            console.log(subType.arr); //[1,2,3,4]

            3.3 组合继承
            通过原型链继承原型对象上的属性和方法，通过盗用构造函数继承对象自身的属性和方法，弥补了原型链和盗用构造函数的不足，是使用最多的继承模式
            缺点是创建一个子类对象时，父类的构造函数会被调用两次
            不想被共享的属性和方法声明在父类构造函数中，希望被共享的属性和方法声明在原型对象中

            function SupType(id, salary) {
            this.id = id; //不希望被共享的属性
            this.salary = salary;}

            SupType.prototype.getId = function () {
                console.log(this.id); //希望共享使用的方法}

            function SubType() {
                SupType.call(this, 1, [10, 20, 15, 25]); //盗用构造函数}

            SubType.prototype = new SupType(); //原型链，子类原型对象指向父类的一个非原型对象

            const subType1 = new SubType();
            const subType2 = new SubType();
            console.log(subType1.id); //1
            console.log(subType2.id); //1
            console.log(subType1.salary); //[10, 20, 15, 25]
            console.log(subType2.salary); //[10, 20, 15, 25]
            subType1.id = 10; //id 属性不共享
            subType1.salary = [0, 0, 0, 0]; //salary 属性不共享
            subType1.getId(); //10，共享的 getId() 方法
            subType2.getId(); //1，
            console.log(subType1.salary); //[0, 0, 0, 0]
            console.log(subType2.salary); //[10, 20, 15, 25]

            3.4 原型式继承
            使用 Object.create() 方法本质上是对给定对象执行浅复制，不需要单独创建构造函数，就可以在多个对象之间共享属性或方法，和原型模式效果一样

            3.5 寄生式继承
            先基于一个对象创建一个新对象，然后再增强这个新对象，最后返回新对象

            function createAnother(original) { //传入初始对象
            let clone = Object(original); //将初始对象传给一个可以返回新对象的函数，如 Object()
            clone.improve = function () { //增强克隆对象，给其增加属性或方法
                //具体增强内容
            };
            return clone; //返回克隆对象
            }

            3.6 寄生式组合继承
            通过寄生式继承原型对象上的属性和方法，通过盗用构造函数继承对象自身的属性和方法
            寄生式组合继承是最佳的继承模式

            function SupType(id, salary) {
            this.id = id; //不希望被共享的属性
            this.salary = salary;}

            SupType.prototype.getId = function () {
                console.log(this.id);} //希望共享使用的方法

            function SubType() {
                SupType.call(this, 1, [10, 20, 15, 25])}; //盗用构造函数

            SubType.prototype = Object(SupType.prototype); //寄生式继承，子类的原型对象指向父类的原型对象，而不是父类的一个非原型对象

            const subType1 = new SubType();
            const subType2 = new SubType();
            console.log(subType1.id); //1
            console.log(subType2.id); //1
            console.log(subType1.salary); //[10, 20, 15, 25]
            console.log(subType2.salary); //[10, 20, 15, 25]
            subType1.id = 10; //id 属性不共享
            subType1.salary = [0, 0, 0, 0]; //salary 属性不共享
            subType1.getId(); //10，共享的 getId() 方法
            subType2.getId(); //1，
            console.log(subType1.salary); //[0, 0, 0, 0]
            console.log(subType2.salary); //[10, 20, 15, 25]

        四、类
        以上各种继承方式可以模拟类似于类的行为，但代码冗长且混乱。ECMAScript 6 引入 class 关键字定义类，是语法糖结构，背后仍然使用原型链和盗用构造函数的方法

            4.1 定义类
            和函数类似，类声明和类表达式两种方式定义类
            函数受函数作用域限制，类受块作用域限制
            类本质上是一种特殊的构造函数

            class Person {}; //类声明
            let Person = class {}; //类表达式

            类可以包含构造函数方法、实例方法、获取函数、设置函数和静态类方法
            默认情况下，类中的代码都在严格模式下运行


            4.2 类构造函数
            用 constructor 关键字定义类构造函数
            必须使用 new 调用类构造函数

            class Person {
                constructor(name) {
                    this.name = name;}}

            const p1 = new Person("Andy");
            console.log(p1.name); //"Andy"

            4.3 实例、原型和类成员
            class Person {
                constructor(name) {
                    this.name = name; //不共享的的属性
                    this.printId = () => {console.log(1)}; //不共享的方法
                }

                get decName() { //获取访问器
                    console.log(this.name)
                }

                set decName(value) { //设置访问器
                    this.name = value;
                }

                print() { //定义在类的原型对象上，不同对象共享此方法
                    console.log("Hello");
                }

                static locate() { //定义在类本身
                    console.log("this is static method")
                }
            }

            4.4 继承
            继承背后使用的依旧是原型链
            1) 继承基础
            使用 extends 支持单继承，继承类或构造函数

            class Human{};
            function Animal(){};

            class male extends Human{}; //继承类
            class female extends Animal{} //继承构造函数

            2) super
            可以在子类的构造函数或静态方法中使用 super

            class Human {
                constructor() {
                    console.log("Super");
                }

                static StaticMethod() {
                    console.log("static super method")
                }
            };

            class Male extends Human {
                constructor() {
                    super(); //相当于 super.constructor()
                }

                static StaticMethod() {
                    super.StaticMethod(); //调用父类静态方法
                }
            };
            new Male(); //"Super"
            Male.StaticMethod(); //"static super method"

            3) 抽象基类
            new.target 保存通过 new 关键字调用的类或函数

            class Vehicle {
                constructor() {
                    if (new.target === Vehicle) { //只要创建 Vehicle 对象 就抛出异常
                        throw new Error('Vehicle cannot be directly instantiated');}}}

            class Bus extends Vehicle {}

            new Bus(); //创建成功
            new Vehicle(); //报错，创建失败

            */


    </script>
</head>
<body>

</body>
</html>