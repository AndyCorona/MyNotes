# 第十二章 shell 编程

### 基础正则

| 元字符    | 作用                                                         |
| --------- | ------------------------------------------------------------ |
| *         | 匹配前一个字符任意次，sa*id==sid，said，saaid，……            |
| .         | 匹配任意一个字符（换行符除外），s.id==said，sbid，scid，……   |
| ^         | 匹配行首，\^said==saidyes……，\^M\==Mr……                      |
| $         | 匹配行尾，said\$==……hesaid，m\$\==……ram                      |
| []        | 匹配括号中任意一个字符，s[oa]id==soid，said                  |
| [^]       | 匹配除中括号以外的任意一个字符，[\^0-9]匹配非数字            |
| \         | 转义符，取消特定符号的特殊含义，\\{ 取消大括号特殊含义       |
| \\{n\\}   | 前一个字符出现n次，[0-9]\\{3\\} 任意数字出现三次             |
| \\{n,\\}  | 前一个字符出现不小于n次，sa\\{3,\\} a字符出现不小于3次       |
| \\{n,m\\} | 前一次字符至少出现n次，最多出现m次，[a-z]\\{3,4\\} 任意小写字母出现 3~4次 |

### 扩展正则

必须用 egrep 或 grep -E 使用。

| 扩展元符号 | 作用                                                    |
| ---------- | ------------------------------------------------------- |
| +          | 匹配前一个字符1~任意次                                  |
| ?          | 匹配前一个字符0~1次                                     |
| \|         | 匹配两个或多个分支，1\|2 会匹配包含1的结果和包含2的结果 |
| ()         | 把括号里的字符串看成一个字符，(dog)+==dog，dogdog，……   |

### 字符截取和替换
1. cut 提取列
   默认分隔符为制表符，且对空格不太支持。
   **cut&nbsp;&nbsp;&nbsp;&nbsp;[选项]&nbsp;&nbsp;&nbsp;&nbsp;文件名**
   -f 列号：提取列数
   -d 分隔符：按指定分隔符分割列
   -c 字符范围：不依赖分隔符，通过字符范围（每一行行首为0）提取。n-表示提取n个字符到行尾，n-m 表示提取 n-m 个字符，-m表示从行首提取到m个字符
   
   `[root@localhost ~]# cut -d ":" -f 1,3 /etc/passwd
   root:0` #从 /etc/passwd 文件下，以:为分隔符，提取第一列和第三列

2.awk编程
**printf&nbsp;&nbsp;&nbsp;&nbsp;'输出类型和输出格式'&nbsp;&nbsp;&nbsp;&nbsp;输出内容**
printf 将输出内容按指定的输出类型和输出格式输出
   输出类型：
   %ns：输出字符串。n代表输出几个字符
   %ni：输出整数。n代表输出几个数字，在 awk 中，只有整数才能进行数值运算
   %m.nf：输出浮点数。m代表输出总位数，n代表小数位
   输出格式：
   \a：输出警告声音
   \b：输出退格键
   \f：清除屏幕
   \n：换行
   \r：回车
   \t：水平制表符
   \v：垂直制表符

`[root@localhost ~]# printf '%s' $(cat /etc/passwd)
root:x:0:0:root:/root:/bin/bash……` #若不指定输出格式，将所有内容连在一起输出

`[root@localhost ~]# printf '%s\n' $(cat /etc/passwd)
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin` #指定输出格式为换行

cut 命令提取列对空格不支持，awk支持空格。
**awk&nbsp;&nbsp;&nbsp;&nbsp;'条件1{动作1}&nbsp;&nbsp;条件2{动作2}……'&nbsp;&nbsp;&nbsp;&nbsp;文件名**
awk是按行读入数据：

- 若有 BEGIN 条件，则先执行 BEGIN 定义的动作。
- 读入第一行，赋予 awk 内建变量 $0(与shell位置参数变量不同)，第一行第一列赋给 $1，第二列赋给 $2，依此类推。
- 依次判断条件。若动作前没有条件，则每读取一行，都会执行一次该动作。若加入条件，则条件满足，动作才执行。
- 读取下一行数据，重复执行以上步骤。

| 条件  | 说明 |
| :---- | ---- |
| BEGIN | 程序尚未读取数据之前，先执行BEGIN里的动作 |
| END   | 程序处理完所有数据，再执行END里的动作 |
| >     | 大于 |
| <     | 小于 |
| >=    | 大于等于 |
| <=    | 小于等于 |
| ==    | 相等 |
| !=    | 不等 |
| A~B   | 判断A字符串是否包含B字符串 |
|A!~B   | 判断A字符串是否不包含B字符串 |
|/正则表达式/  | 支持正则表达式 |

| 动作         | 说明             |
| ------------ | ---------------- |
| printf       | 格式化输出       |
| 流程控制语句 | 顺序、循环、分支 |

| 内置变量 | 作用                           |
| -------- | ------------------------------ |
| $0       | 代表目前 awk 所读入的整行数据  |
| $n       | 代表目前读入行的第n列          |
| NF       | 当前行拥有的总列数             |
| NR       | 当前 awk 处理第几行            |
| FS       | 自定义分隔符。默认分隔符是空格 |

#空格为分隔符，提取每行第五列，并换行输出
`[root@localhost ~]# df -h | awk '{printf $5 "\n"}'`

#如果第二列数据包含字符串 sc，则打印第六列数据。注意字符串必须用/ /包含。
`[root@localhost ~]# awk '$2~/sc/{printf $6 "\n"}' test.txt`

#awk 读取数据前设置分隔符为:，每行输出第一列
`[root@localhost ~]# cat /etc/passwd | awk 'BEGIN{FS=":"} {printf $1 "\n"}'`

3. sed 命令
   和 vim 类似，但是不用进行交互，适合用在脚本中修改文件内容（必须开启 -i 选项）
   **sed&nbsp;&nbsp;&nbsp;&nbsp;[选项]&nbsp;&nbsp;&nbsp;&nbsp;'[动作]'&nbsp;&nbsp;&nbsp;&nbsp;文件名**
   选项：
   -n：sed开启此选项，只有经过sed处理的数据输出到屏幕上。默认把文件里所有数据输出到屏幕
   -e：允许执行多条sed命令 
   -r：在sed中支持扩展正则表达式
   -i：sed直接修改原文件数据，而不是在屏幕上输出
   动作：
   a：在当前行后面追加任意行。多行用 \\ 代表输入还未结束
   c：行替换，用c后面的字符串替换当前行。\\ 作用同上
   i：在当前行前面插入任意行。\\ 作用同上
   d：删除当前行
   p：打印，输出当前行
   s：字符串替换，用一个字符串替换另一个字符串。格式与vim替换相似。格式为：`行范围s/旧字符串/新字符串/g`

#打印文件里的第二行
`[root@localhost ~]# sed -n '2p' test.txt`

#在屏幕输出上（不修改源文件），删除第2~4行
`[root@localhost ~]# sed '2,4d' test.txt`
`[root@localhost ~]# sed -e '2d ; 4d' test.txt ` #多条命令之间用;分开

#修改源文件，在当前行前面插入一行数据 hello
`[root@localhost ~]# sed -i 'i hello' test.txt `

#在屏幕输出上（不修改源文件），在第一行后面追加两行数据 HELLO 和 WORLD
`[root@localhost ~]# sed -n '1a HELLO \
> WORLD' test.txt
HELLO 
WORLD`

#修改源文件，修改第三行数据为 NO
`[root@localhost ~]# sed -i '3c NO' test.txt`

#修改源文件，替换第二行NO为YES
`[root@localhost ~]# sed -i '2s/NO/YES/g' test.txt`

4. 字符处理命令
   **排序**
   **sort&nbsp;&nbsp;&nbsp;&nbsp;[选项]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文件名**
   -f：忽略大小写
   -b：忽略每行前面空白部分
   -n：以数值型排序，默认用字符串排序
   -r：反向排序
   -u：删除重复行
   -t：指定分隔符，默认是制表符
   -k n[,m]：按照指定列范围排序，从n到m列（默认到行尾）

#默认以每行开头第一个字符排序
`[root@localhost ~]# sort /etc/passwd` 

#以第三列数值型进行排序，分隔符为:
`[root@localhost ~]# sort -n -k 3 -t : /etc/passwd`

**取消重复行**
`[root@localhost ~]# uniq -i /etc/passwd` #-i 忽略大小写，功能和 sort -u 一样

**统计**
wc

### 条件判断

通过 `test 测试选线` 或者 `[ 测试选项 ]`进行各种判断，正确返回真(0)，错误返回假(非0)

1. 按照文件类型判断

| 测试选项    | 作用                                     |
| ----------- | ---------------------------------------- |
| -b 文件     | 判断该文件是否存在，且是否为块设备文件   |
| -c 文件     | 判断该文件是否存在，且是否为字符设备文件 |
| **-d 文件** | 判断该文件是否存在，且是否为目录文件     |
| **-e 文件** | 判断该文件是否存在                       |
| **-f 文件** | 判断该文件是否存在，且是否为普通文件     |
| -L 文件     | 判断该文件是否存在，且是否为软链接文件   |
| -p 文件     | 判断该文件是否存在，且是否为管道文件     |
| **-s 文件** | 判断该文件是否存在，且文件是否有内容     |
| -S 文件     | 判断该文件是否存在，且是否为套接字文件   |

`[root@localhost ~]# [ -e /root/test ] && echo yes || echo no
no` #判断 /root/test 文件是否存在

`[root@localhost ~]# [ -d /root/ ] && echo yes || echo no
yes` #判断 /root/ 目录是否存在

2. 按照文件权限判断
无法区分权限属于所有者、所著组或其他人，只要所有者、所属组或其他人有对应权限，权限判断为真。若要区分对待，先截取对应权限再判断

| 测试选项 | 作用                                     |
| -------- | ---------------------------------------- |
| -r 文件  | 判断该文件是否存在，且是否拥有读权限     |
| -w 文件  | 判断该文件是否存在，且是否拥有写权限     |
| -x 文件  | 判断该文件是否存在，且是否拥有执行权限   |
| -u 文件  | 判断该文件是否存在，且是否拥有 SUID 权限 |
| -g 文件  | 判断该文件是否存在，且是否拥有SGID 权限  |
| -k 文件  | 判断该文件是否存在，且是否拥有SBIT 权限  |


`[root@localhost ~]# [ -x /root/sh/count.sh ] && echo yes || echo no
yes`  #判断该文件是否有执行权限

`[root@localhost ~]# [ -r /root/sh/ ] && echo yes || echo no
yes`  #判断该目录是否有读权限

3. 两个文件之间比较

| 测试选项        | 作用                                                |
| --------------- | --------------------------------------------------- |
| 文件1 -nt 文件2 | 判断文件1的修改时间的是否比文件2新                  |
| 文件1 -ot 文件2 | 判断文件1的修改时间的是否比文件2旧                  |
| 文件1 -ef 文件2 | 判断文件1和文件2是否为同一个文件（i节点号是否相同） |

4. 两个整数之间比较

| 测试选项        | 作用                       |
| --------------- | -------------------------- |
| 整数1 -eq 整数2 | 判断两整数是否相等         |
| 整数1 -ne 整数2 | 判断两整数是否不相等       |
| 整数1 -gt 整数2 | 判断整数1是否大于整数2     |
| 整数1 -lt 整数2 | 判断整数1是否小于整数2     |
| 整数1 -ge 整数2 | 判断整数1是否大于等于整数2 |
| 整数1 -le 整数2 | 判断整数1是否小于等于整数2 |

`[root@localhost ~]# param1=10`  #给变量 param1 赋值
`[root@localhost ~]# [ $param1 -gt 9 ] && echo yes || echo no
yes` #判断变量值是否大于9

`[root@localhost ~]# [ 10 -ge 11 ] && echo yes || echo no
no`

5. 字符串判断

| 测试选项           | 作用                           |
| ------------------ | ------------------------------ |
| -z 字符串          | 判断字符串是否为空             |
| -n 字符串          | 判断字符串是否非空             |
| 字符串1 == 字符串2 | 判断字符串1是否和字符串2相等   |
| 字符串1 != 字符串2 | 判断字符串1是否和字符串2不相等 |

`[root@localhost ~]# [ -n $param1 ] && echo yes || echo no
yes`  #判断变量值是否为空

6. 多重判断

| 测试选项       | 作用   |
| -------------- | ------ |
| 判断1 -a 判断2 | 逻辑与 |
| 判断1 -o 判断2 | 逻辑或 |
| ! 判断         | 逻辑非 |

`[root@localhost ~]# [ -n $param1 -a $param1 -gt 20 ] && ehco yes || echo no
no` #判断变量值是否存在且大于20

### 流程控制
1. 条件判断
    if语句语法格式：

  ```shell
  #单分支if语句
  if [ 条件判断式 ]
      then 
      程序体
  fi
  ```
  ```shell
   #双分支if语句
  if [ 条件判断式 ]
      then 
          程序体1
      else
          程序体2
  fi
  ```

  ```shell
   #多分支if语句
  if [ 条件判断式  ]
      then 
          程序体1
  elif [ 条件判断式2 ]
      then
          程序体2
  ……
  
  else
      程序体n
  fi
  ```
  脚本依次判断分支条件，根据条件结果决定是否执行对应的程序体。在执行程序体后，加入 `exit 数字` 可退出脚本并返回该数字

用法示例：

  ```shell
#!/bin/bash

#获取根目录的使用情况
var=$(df -h | grep /dev/sda5 | awk '{print $5}' | cut -d "%" -f 1)

if [ $var -gt 80 ]
        then
        echo 'usage > 80%'
        exit 100
elif [ $var -gt 40 ]
        then
        echo 'usage > 40%'
else
        echo 'usage is normal'
fi

  ```
case语句语法格式：
  ```shell
  #case语句
  case $变量名 in
      ''值1'')
          程序体1
          ;;
      ''值2'')
          程序体2
          ;;
          
  ……
  
        *）
         程序体n
         ;;
  esac
  
  ```

2. 循环控制
for语句语法一（推荐使用）：
```shell
#用空格分隔每个值，每次循环把值赋给变量
for 变量 in 值1 值2 值3 …… 
	do
		程序体
	done
```

用法示例：
```shell
#!/bin/bash

#提取除了root用户之外的所有登录用户
name=$(cat /etc/passwd | grep '/bin/bash' | grep -v 'root' | cut -d ":" -f 1)

for i in $name #换行做分隔符，每行数据赋给i
        do
                #删除用户及其目录
                # &>/dev/null 代表将命令的所有输出结果扔进垃圾桶，不显示
                userdel -r $i &>/dev/null
        done
```

for语句语法二：
```
#
for ((初始值;循环控制条件;迭代部分))
	do 
		程序体
	done
```

用法示例：
```shell
#!/bin/bash

sum=0
for(( i=1;i<=100;i=i+1 ))
        do
                sum=$(( $i+$sum ))
        done
echo $sum
```
while语句语法格式：
只要条件判断式成立，就进行循环
```shell
while [ 条件判断式 ]
	do
		程序
	done
```
用法示例：
```shell
#!/bin/bash

i=1
sum=0

while [ $i -le 100 ]
        do
                sum=$(( $sum+$i ))
                i=$(( $i+1 ))
        done
echo $sum
```

until语句语法格式：
和 while 语句相反，只要条件判断式不成立就进行循环
```shell
until [ 条件判断式 ]
	do
		程序
	done
```
用法示例：
```shell
#!/bin/bash

i=1
sum=0

until [ $i -gt 100 ]
        do
                sum=$(( $sum+$i ))
                i=$(( $i+1 ))
        done
echo $sum
```

exit、break和continue
shell 脚本中，`exit 返回值`语句用来退出当前脚本，可以没有返回值。通过 $? 可查看返回值。 
break 跳出当前循环，continue 跳过当此循环
