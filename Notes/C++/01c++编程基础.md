# 编程语言基础

#### C++ 简介

C++ 是一种静态类型、编译式的、通用的、 大小写不敏感的、不规则的编程语言，支持过程化编程和面向对象编程和泛型编程。C++ 是 C 的一种超集，任何合法的 C 程序都是合法的 C++ 程序

C++ 标准库包括三个重要部分：

1.   核心语言：提供了所有构建，包括变量、数据类型和常量等等
2.   C++ 标准库，提供了大量函数，用于操作文件、字符串等
3.   标准模板库，提供了大量方法，用于操作数据结构等

C++ 通常用于编写设备驱动程序和其他要求有实时性的直接操作硬件的软件。Mac 和 Windows 系统的主要接口是使用 C++编写的

#### 标识符

C++ 标识符用来表示变量、函数、类和模块或其用户自定义的项目名称。一个标识符以字母 A-Z 或 a-z 或下划线开始，后面跟着多个字母、下划线和数字。

#### 关键字

|              |           |                  |          |
| ------------ | --------- | ---------------- | -------- |
| sm           | else      | new              | this     |
| auto         | enum      | operator         | throw    |
| bool         | explicit  | private          | true     |
| break        | export    | protected        | try      |
| case         | extern    | public           | typedef  |
| catch        | false     | register         | typeid   |
| char         | float     | reinterpret_cast | typename |
| class        | for       | return           | union    |
| const        | friend    | short            | unsigned |
| const_cast   | goto      | signed           | using    |
| continue     | if        | sizeof           | virtual  |
| default      | inline    | static           | void     |
| delete       | int       | static_cast      | volatile |
| do           | long      | struct           | wchar_t  |
| double       | mutable   | switch           | while    |
| dynamic_cast | namespace | template         |          |

#### 注释

单行注释 //

多行注释 /**/

```c++
/*
* //多行注释内部可以嵌套单行注释
*/
```

#### 数据类型

| 布尔型   | bool    |
| -------- | ------- |
| 字符型   | char    |
| 整型     | int     |
| 浮点型   | float   |
| 双浮点型 | double  |
| 无类型   | void    |
| 宽字符型 | wchar_t |

一些基本数据类型可以使用一个或多个类型修饰符进行修饰 ```signed```, ```unsinged```, ```short```, ```long```

| 类型                | 位数          | 范围                                                         |
| ------------------- | ------------- | ------------------------------------------------------------ |
| char                | 1 个字节      | -128 到 127 或者 0 到 255                                    |
| unsigned char       | 1 个字节      | 0 到 255                                                     |
| signed char         | 1 个字节      | -128 到 127                                                  |
| int                 | 4 个字节      | -2147483648 到 2147483647                                    |
| unsigned int        | 4 个字节      | 0 到 4294967295                                              |
| signed int          | 4 个字节      | -2147483648 到 2147483647                                    |
| short int           | 2 个字节      | -32768 到 32767                                              |
| unsigned short int  | 2 个字节      | 0 到 65,535                                                  |
| signed short int    | 2 个字节      | -32768 到 32767                                              |
| long int            | 8 个字节      | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807      |
| signed long int     | 8 个字节      | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807      |
| unsigned long int   | 8 个字节      | 0 到 18,446,744,073,709,551,615                              |
| float               | 4 个字节      | 精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字) |
| double              | 8 个字节      | 双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字) |
| long double         | 16 个字节     | 长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。 |
| wchar_t (short int) | 2 或 4 个字节 | 1 个宽字符                                                   |

```c++
#include <iostream>
using namespace std;
 
int main ()
{
   // 数字定义
   short  s;
   int    i;
   long   l;
   float  f;
   double d;
   
   // 数字赋值
   s = 10;      
   i = 1000;    
   l = 1000000; 
   f = 230.47;  
   d = 30949.374;
   
   // 数字输出
   cout << "short  s :" << s << endl;
   cout << "int    i :" << i << endl;
   cout << "long   l :" << l << endl;
   cout << "float  f :" << f << endl;
   cout << "double d :" << d << endl;
 
   return 0;
}
```

C++ 内置了数学函数，引用数学头文件 \<cmath\>。

#### typedef

typedef 可以为一个已有的类型取一个新的名字。

1.   定义一个类型的别名
2.   定义结构体的别名

```c++
//typedef 将 char * 定义为 CHAR
typedef char *CHAR;
char *str1 = "hello";
CHAR str2 = "hell1o";
//true
cout << (str1 == str2);
```

```c++
//没有使用别名之前，定义结构体类型为 point 的变量 pot
struct point {
    int x;
    int y;
} pot;
struct point p1;

//使用别名之后，定义结构体类型为 ptr，其别名为 potr
typedef struct ptr {
    int x;
    int y;
} potr;
ptr p2;
potr p3;
return 0;
```

#### 枚举类

枚举类是 C++ 中的一种派生数据类型，它有用户定义的若干枚举常量的集合构成。枚举就是将变量的值一一列举出来。枚举常量只能用标识符表示。

枚举常量的值默认从 0 开始，可以自定义枚举常量值，枚举常量的值可以重复，后续的值会保证连续。

```c++
enum color {
    //0，默认的枚举常量值
    red,
    //5，自定义枚举常量值
    green = 5,
    //6，保证从上一个枚举值延续
    blue
} variable;
```

#### 变量

变量是程序可操作的存储区的名称。

**变量类型**

类型决定了变量存储的大小和布局。该范围内的值都可以存储在内存中，运算符可以应用于变量上。

**变量声明**

```c++
#include <iostream>
using namespace std;
 
// 变量声明
extern int a, b;
extern int c;
extern float f;
  
int main ()
{
  // 变量定义
  int a, b;
  int c;
  float f;
 
  // 实际初始化
  a = 10;
  b = 20;
  c = a + b;
 
  cout << c << endl ;
 
  f = 70.0/3.0;
  cout << f << endl ;
 
  return 0;
}
```

函数和变量类似，都可以将声明和定义分开。


```c++
// 函数声明（原型函数）
int func();

int main()
{
    // 函数调用
    int i = func();
}

// 函数定义
int func()
{
    return 0;
}
```

**变量定义**

![img](https://www.runoob.com/wp-content/uploads/2015/01/cpp-variable-types-2020-12-14.png)

带有静态存储持续时间的变量会被隐式初始化为 NULL，即 0。其他所有的变量的初始值是未定义的。

**左右值**

左值：指向内存位置的表达式称为左值表达式。左值可以出现在赋值号的左边或右边。
右值：存储在内存中某些地址的数值。右值不能对其进行赋值。右值可以出现在赋值号的右边，但不能出现在赋值号的左边。

```c++
//合法
int g = 20;
//不合法
10 = 20;
```

#### 变量作用域

作用域是程序的一个区域，一般来说有三个地方可以定义变量：

-   在函数或者一个代码块内部声明的变量，称为局部变量。
-   在函数参数中的变量，称为形式参数。
-   在所有函数外部声明的变变量，称为全局变量

**局部变量**

局部变量只能被函数内部或者代码块内部使用，系统不会对其初始化。

```c++
#include <iostream>
using namespace std;
 
int main ()
{
  // 局部变量声明
  int a, b;
  int c;
 
  // 实际初始化
  a = 10;
  b = 20;
  c = a + b;
 
  cout << c;
 
  return 0;
}
```

**全局变量**

全局变量在程序整个生命周期都有效，全局变量可以被任何函数访问，系统会自动初始化为各类型的 0 值。

```c++
#include <iostream>
using namespace std;
 
// 全局变量声明
int g;
 
int main ()
{
  // 局部变量声明
  int a, b;
 
  // 实际初始化
  a = 10;
  b = 20;
  g = a + b;
 
  cout << g;
 
  return 0;
}
```

#### 常量

常量是固定值，在程序执行期间不会改变，即在定义后不能进行修改，也称为字面量。

**整数常量**

整数常量可以是十进制、八进制或十六进制，前缀 0x (0X) 代表十六进制， 0 代表八进制。后缀 U(u) 代表无符号整数，L(l) 代表长整数。

**浮点常量**

浮点常量由整数部、小数部分和指数部分组成。

```c++
3.14159       // 合法的 
314159E-5L    // 合法的 
510E          // 非法的：不完整的指数
210f          // 非法的：没有小数或指数
.e55          // 非法的：缺少整数或分数
```

**布尔常量**

布尔常量共有两个，true 和 false。

**字符常量**

字符常量是括在单括号中，如果以 L 开头，说明为一个宽字符，否则就是一个窄字符，类型为 char。

字符串常量可以是一个普通的字符（'x'），一个转义序列（'\t'）或一个通用的 Unicode 字符（'\u02C0'）。

**字符串常量**

字符串常量或字面量括在双引号中，一个字符串也可以包括普通的字符、转义序列和通用的 Unicode 字符。

**定义常量**

使用 #define 预处理器或 const 关键字定义常量。

```c++
#define LENGTH 10
#define WIDTH 5
```

使用 const 声明指定类型的常量

```c++
const int LENGTH = 10;
const int WIDTH = 5;
```

#### 类型修饰符

在 char, int, double 等数据类型前放置修饰符。

signed, unsigned, long, short 可应用于整型。signed 和 unsigned 可应用于字符型，long 可应用于双精度。

unsigned 和 signed 也可以作为 long 或 short 修饰符前缀。

#### 类型限定符

const: const 类型的对象在程序执行期间不能被修改改变
volatile: 让程序可以直接从内存中读取变量，而不是读取缓存
restrict: 由 restrict 修饰的指针是唯一一种访问它所指向的对象的一种方式。

#### 存储类

存储类定义了程序中变量的范围与生命周期。修饰符放置在所修饰的类型之前。

**register**

register 存储类定义将局部变量存储在寄存器而不是内存中，但是具体是否存储在寄存器中，还和硬件和实现相关。

**static**

static 存储类保持局部变量在程序生命周期中一直存在，不需要再进入和离开作用域时创建和销毁。
static 修饰全局变量时会使变量的作用域限制在声明它的文件内。

**extern**

extern 存储类提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。extern 用于当有多个文件共享相同的全局变量或函数的时。

**thread_local**

thread_local 修饰符修饰的变量尽可在创建它的线程上访问。变量在创建线程时创建，在销毁线程时销毁。每个线程都可以有自己的变量副本。thread_local 可以与 extern, static 一起使用。thread_local 可以用于变量声明和定义，但是不能用于函数声明与定义。

#### 运算符

**算术运算符**

| 运算符 | 描述                                                         | 实例  |
| ------ | ------------------------------------------------------------ | ----- |
| +      | 把两个操作数相加                                             | a + b |
| -      | 从第一个操作数中减去第二个操作数                             | a - b |
| *      | 把两个操作数相乘                                             | a * b |
| /      | 分子除以分母                                                 | a / b |
| %      | 取模运算符，整除后的余数                                     | a % b |
| ++     | 自增运算符，整数值增加 1 | a++   |
| --     | 自减运算符，整数值减少 1 | a--   |

**关系运算符**

| 运算符 | 描述                                                         | 实例   |
| ------ | ------------------------------------------------------------ | ------ |
| ==     | 检查两个操作数的值是否相等，如果相等则条件为真。             | a == b |
| !=     | 检查两个操作数的值是否相等，如果不相等则条件为真。           | a != b |
| >      | 检查左操作数的值是否大于右操作数的值，如果是则条件为真。     | a > b  |
| <      | 检查左操作数的值是否小于右操作数的值，如果是则条件为真。     | a < b  |
| >=     | 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 | a >= b |
| <=     | 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 | a <= b |

**逻辑运算符**

| 运算符 | 描述                                                       | 实例     |
| ------ | ---------------------------------------------------------- | -------- |
| &&     | 与运算符。如果两个操作数都 true，则条件为 true。           | a && b   |
| \|\|   | 或运算符。如果两个操作数中有任意一个 true，则条件为 true。 | a \|\| b |
| !      | 非运算符。如果条件为 true 则逻辑非运算符将使其为 false。   | !a       |

**位运算符**

| 运算符 | 描述     |
| ------ | -------- |
| &      | 按位与   |
| \|     | 按位或   |
| ^      | 按位异或 |
| ~      | 按位取反 |
| <<     | 左移     |
| >>     | 右移     |

**赋值运算符**

| 运算符 | 描述                                             | 实例                            |
| ------ | ------------------------------------------------ | ------------------------------- |
| =      | 赋值运算符，把右边操作数的值赋给左边操作数       | C = A + B 将把 A + B 的值赋给 C |
| +=     | 把右边操作数加上左边操作数的结果赋值给左边操作数 | C += A 相当于 C = C + A         |
| -=     | 把左边操作数减去右边操作数的结果赋值给左边操作数 | C -= A 相当于 C = C - A         |
| *=     | 把右边操作数乘以左边操作数的结果赋值给左边操作数 | C *= A 相当于 C = C * A         |
| /=     | 把左边操作数除以右边操作数的结果赋值给左边操作数 | C /= A 相当于 C = C / A         |
| %=     | 求两个操作数的模赋值给左边操作数                 | C %= A 相当于 C = C % A         |
| <<=    | 左移且赋值运算符                                 | C <<= 2 等同于 C = C << 2       |
| >>=    | 右移且赋值运算符                                 | C >>= 2 等同于 C = C >> 2       |
| &=     | 按位与且赋值运算符                               | C &= 2 等同于 C = C & 2         |
| ^=     | 按位异或且赋值运算符                             | C ^= 2 等同于 C = C ^ 2         |
| \|=    | 按位或且赋值运算符                               | C \|= 2 等同于 C = C \| 2       |

**杂项运算符**

| 运算符            | 描述                                                         |      |
| ----------------- | ------------------------------------------------------------ | ---- |
| sizeof            | 返回变量所占用的内存大小                                     |      |
| Condition ? X : Y | 三元运算符。如果 Condition 为真 ? 则返回 X 否则返回 Y        |      |
| ,                 | [逗号运算符](https://www.runoob.com/cplusplus/cpp-comma-operator.html)会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。 |      |
| . 和 ->           | 成员运算符用于引用类、结构和共用体的成员。                   |      |
| Cast              | 强制类型转换，将一种数据类型转为另一种数据类型，例如 int(2.2) |      |
| &                 | & 返回变量的地址， &a 将给出变量 a 的内存地址                |      |
| *                 | \* 指向一个变量，指针中保存变量的内存地址。                  |      |

**运算符优先级**

| 类别       | 运算符                            | 结合性   |
| ---------- | --------------------------------- | -------- |
| 后缀       | () [] -> . ++ - -                 | 从左到右 |
| 一元       | + - ! ~ ++ - - (type)* & sizeof   | 从右到左 |
| 乘除       | * / %                             | 从左到右 |
| 加减       | + -                               | 从左到右 |
| 移位       | << >>                             | 从左到右 |
| 关系       | < <= > >=                         | 从左到右 |
| 相等       | == !=                             | 从左到右 |
| 位与 AND   | &                                 | 从左到右 |
| 位异或 XOR | ^                                 | 从左到右 |
| 位或 OR    | \|                                | 从左到右 |
| 逻辑与 AND | &&                                | 从左到右 |
| 逻辑或 OR  | \|\|                              | 从左到右 |
| 条件       | ?:                                | 从右到左 |
| 赋值       | = += -= *= /= %=>>= <<= &= ^= \|= | 从右到左 |
| 逗号       | ,                                 | 从左到右 |

#### 流程控制

**循环**

```c++
for (int ix= 0; ix < 10; ix++) {
	//循环体
}
```

```c++
int ix = 0;
while (ix < 10) {
    //循环体
    ix++;
}
```

```c++
int ix = 0;
do {
    //循环体
    ix++;
} while (ix < 10);
```

**分支判断**

```c++
int ix = 0;
if (ix < 10) {

}
```

```c++
if (ix < 10) {

} else {

}
```

```c++
if (ix < 10) {

} else if (ix >= 10 && ix < 20) {

} else {

}
```

```c++
int ix = func();
switch (ix) {
    case 10:
        //分支结构1;
        break;
    case 20:
        //分支结构2;
        break;
    default:
        //默认分支结构
        break;
}
```

#### 函数

函数是一组一起执行一个任务的语句。每个 C++ 程序都至少有一个 main() 入口函数。函数声明提供函数名称，返回值和参数。函数定义提供了函数的具体实现。

##### 定义函数

```c++
return_type function_name(parameter list) {
    body of the_function
}
```

返回类型：一个函数只能返回一个值。需要指明返回值的返回类型，若函数没有返回值，返回类型为 void。
函数名称：函数的实际名称，函数名称和参数列表构成函数签名。
参数：形式参数就是占位符，形式参数列表包括参数类型、个数和数量。函数可以没有参数。当函数被调用时，会向函数传递一个值，这个值被称为实际参数。
函数主体：函数主体包括一组定义函数执行任务的语句。

```c++
int max(int num1, int num2) {
    int result;
    if (num1 > num2) {
        result = num1;
    }
    return num2;
}
```

##### 函数声明

函数声明告诉编译器函数名称及如何调用函数。函数的声明和函数的定义可以分开。

```c++
return_type function_name(parameter list);
```

在函数声明中，只有参数类型是必需的，函数名称不需要。

##### 调用函数

当程序调用函数时，程序控制权会转移给被调用的函数，被调用函数执行。执行完毕后控制权交还主程序。

##### 函数参数

如果函数要使用参数，必须声明其所接受的变量，这些变量称为函数的形式参数。当调用函数时，有三种向函数传递参数的方式：

| 调用类型 | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| 传值调用 | 参数的实际值赋给形式参数。即直接传入变量，修改函数内的形式参数对实际参数没有影响 |
| 指针调用 | 把参数的地址赋给形式参数，即传入变量内存地址，修改形式参数会影响实际参数 |
| 引用调用 | 把参数的引用赋给形式参数，即传入变量指针，修改形式参数会影响实际参数 |

c++ 默认使用传值调用来传递参数。

```c++
void swap_by_value(int, int);
void swap_by_pointer(int &, int &);
void swap_by_reference(int *, int *);

int main() {
    int num1 = 10, num2 = 20;
    cout << "num1 is " << num1 << ", num2 is " << num2 << endl;
    swap_by_value(num1, num2);
    cout << "num1 is " << num1 << ", num2 is " << num2 << endl;

    int num3 = 10, num4 = 20;
    cout << "num3 is " << num3 << ", num4 is " << num4 << endl;
    swap_by_pointer(num3, num4);
    cout << "num3 is " << num3 << ", num4 is " << num4 << endl;

    int num5 = 10, num6 = 20;
    cout << "num5 is " << num5 << ", num6 is " << num6 << endl;
    swap_by_reference(&num5, &num6);
    cout << "num5 is " << num5 << ", num6 is " << num6 << endl;

    return 0;
}

/*
 * 传值调用，传入变量，函数内对形参的修改不会影响实参
 */
void swap_by_value(int num1, int num2) {
    int temp = num1;
    num1 = num2;
    num2 = temp;
}

/*
 * 指针调用，传入变量内存地址，函数内对形参的修改会影响实参
 */
void swap_by_pointer(int &num1, int &num2) {
    int temp = num1;
    num1 = num2;
    num2 = num1;
}

/*
 * 引用调用，传入变量指针，函数内对形参的修改会影响实参
 */
void swap_by_reference(int *num1, int *num2) {
    int temp = *num1;
    *num1 = *num2;
    *num2 = temp;
}
```

#####  参数默认值

定义一个函数时，可以给函数的参数指定默认值。默认值只能指定一次，可以在函数声明或者函数定义处。默认值解析从最右边开始。

```c++
//非法，默认值右侧的参数必须都有默认值
void func(int = 10, int);
//合法
void func1(int = 10, int = 20);
```

**Lambda 函数与表达式**

#### 数组

数组是存储一个固定大小相同类型元素的顺序集合。

##### 声明数组

数组大小必须是一个大于零的常量。

```c++
type arratName[arraySize];
```

##### 初始化数组

可以逐个初始化数组，也可以使用初始化语句。

```c++
//第一个元素为 1，其余元素初始化为 0
int arr[10] = {1};

//不指明长度，则数组长度为初始化元素个数
int arr[] = {1,2};

//逐个初始化
arr[5] = 10;
```

##### 访问数组元素

数组元素可以通过索引进行访问。```arr[2]```

##### 多维数组

以二维数组为例，初始化并访问二维数组元素。

```c++
int arr[3][3] = {{1,2},{1,2},{1,2}};

int val = arr[2][2];
```

#### 字符串

c++ 提供了两种风格的字符串表示形式：C 风格字符串和 C++ 引入的 string 类型。

​	**C 风格字符串**

C 风格字符串以 null (\0) 字符结尾。

```c++
#include <iostream>
#include <cstring>

using namespace std;

int main() {
    char str1[10] = "hello";
    char str2[10] = "world";
    //将 str1 和 str2 连接
    cout << strcat(str1, str2) << endl;
    //计算字符串长度
    cout << strlen(str1) << endl;
    return 0;
}
```

**C++ 中的  string 类**

C++ 标准库支持所有操作，还支持其他更多功能。

```c++
#include <iostream>
#include <string>  
int main() {
    string string1 = "hello";
    string string2 = "world";
    //连接两个字符串
    cout << string1 + string2 << endl;
    //计算字符串长度
    cout << string1.size() << endl;
    return 0;
}
```

#### 指针

每一个变量都有一个内存地址，通过 & 运算符访问内存地址。指针是一个变量，其值为另一个变量的地址，即内存的直接地址。所有指针不管指向何种数据类型，都是用一个十六进制的数表示内存地址。

```c++
type *var-name
```

##### 空指针

为指针变量赋值一个 NULL 值表示这是一个空指针。NULL 指针是一个定义在标准库中的值为零的常量。如果未初始化一个指针，指针可能保存垃圾值。

```c++
int *ptr;
ptr = NULL;
if (!ptr) {
    cout << "空指针" << endl;
}

```

##### 指针的算术运算

指针用一个数值表示地址，可以对指针进行地中算术运算：--,  ++, +, -

**递增一个指针**

一个 int 类型的指针，将指针++ 后指针将移动到下一个内存地址，即往后移动 4 字节。

```c++
int main() {
    int arr[3] = {10, 20, 30};
    int *ptr = arr;
    for (int ix = 0; ix < 2; ix++) {
        cout << "指针所指向内存地址为：" << ptr << endl;
        cout << "指针所指向变量的值为：" << *ptr << endl;
        ptr++;
    }
    return 0;
}
```

**递减一个指针**

指针的递减类似指针的递增。

**指针的比较**

指针可以用关系运算符进行比较，例如 <, >, ==。如果两个指针指向两个相关的变量，则可以对指针比较大小。

```c++
int *start_ptr = arr;
while (start_ptr <= &arr[2]) {
    cout << "指针所指向的内存地址为：" << start_ptr << endl;
    cout << "指针所指向的变量的值为：" << *start_ptr << endl;
    start_ptr++;
}
```

##### 指针与数组

数组是一个指向数组开头的常量，不能用于左值。

```c++
int arr[3];
cout << "数组首元素的值" << *arr << endl;
cout << "数组首元素的内存地址" << arr << endl;
//不合法，常量不能被更改
*arr++;
//合法。
*(arr + 3);
```

##### 指针数组

用一个数组保存指针称为指针数组。

```c++
int main() {
    //指针数组，保存两个 int 指针
    int *ptr_arr[2];
    int arr1[] = {1,2};
    int arr2[] = {3,4};
    ptr_arr[0] = &arr1[0];
    ptr_arr[0] = &arr2[0];
    return 0;
}
```

##### 指向指针的指针（多级间接寻址）

指向指针的指针是一个多级间接寻址的形式，形成一个指针链。即一个指针保存另一个指针的内存地址。

```c++
int main() {
    int num = 10;
    int *ptr = &num;
    int **second_ptr = &ptr;
    cout << "变量的值为：" << num << endl;
    cout << "变量的值为：" << *ptr << endl;
    cout << "变量的值为：" << **second_ptr << endl;
    return 0;
}
```

##### 传递指针给函数

```c++
void swap(int *, int *);

int main() {
    int num1 = 10;
    int num2 = 20;
    int *prt1 = &num1;
    int *ptr2 = &num2;
    cout << "交换之前：" << num1 << "<->" << num2 << endl;
    swap(prt1, ptr2);
    cout << "交换之后：" << num1 << "<->" << num2 << endl;
    return 0;
}

void swap(int *num1, int *num2) {
    int temp = *num1;
    *num1 = *num2;
    *num2 = temp;
}
```

##### 从函数返回指针

```c++
int *max(int *num1, int *num2) {
    if (*num1 > *num2) {
        return num1;
    }
    return num2;
}
```

#### 引用

引用是一个别名，表示已经存在的一个变量。引用和指针的区别如下：

1.   不存在空引用，引用必须连接到一块合法的内存；存在空指针
2.   一旦引用被初始化，就不能指向另一个对象；指针可以指向其他变量
3.   引用必须 在初始化时被创建，指针可以在任何时间被初始化

##### 引用作为参数

```c++
void swap(int &, int &);
int max(int &, int &);

int main() {
    int num1 = 10;
    int num2 = 20;
    cout << "交换之前：" << num1 << "<->" << num2 << endl;
    swap(num1, num2);
    cout << "交换之后：" << num1 << "<->" << num2 << endl;
    cout << "较大值为：" << max(num1, num2) << endl;
    return 0;
}

void swap(int &num1, int &num2) {
    int temp = num1;
    num1 = num2;
    num2 = temp;
}

int max(int &num1, int &num2) {
    if (num1 > num2) {
        return num1;
    }
    return num2;
}
```

##### 引用作为返回值

返回一个引用与返回一个指针类似，例如返回 int&。

#### 日期和时间

C++ 没有提供日期类型，需要在 C++ 程序中引入 \<ctime\> 头文件。结构类型 tm 把日期和时间以 C 结构的形式保存。

```c++
struct tm {
    int tm_sec;   // 秒，正常范围从 0 到 59，但允许至 61
    int tm_min;   // 分，范围从 0 到 59
    int tm_hour;  // 小时，范围从 0 到 23
    int tm_mday;  // 一月中的第几天，范围从 1 到 31
    int tm_mon;   // 月，范围从 0 到 11
    int tm_year;  // 自 1900 年起的年数
    int tm_wday;  // 一周中的第几天，范围从 0 到 6，从星期日算起
    int tm_yday;  // 一年中的第几天，范围从 0 到 365，从 1 月 1 日算起
    int tm_isdst; // 夏令时
};
```

大多数与时间相关的函数都使用了 tm 结构


```c++
int main() {
    // 基于当前系统的当前日期/时间
    time_t now = time(0);

    // 把 now 转换为字符串形式
    char *dt = ctime(&now);

    cout << "本地日期和时间：" << dt << endl;

    // 把 now 转换为 tm 结构
    tm *gmtm = gmtime(&now);
    dt = asctime(gmtm);
    cout << "UTC 日期和时间：" << dt << endl;
}
```

#### 基本输入输出

C++ 标准库提供了一组丰富的输入输出功能。IO 流是字节序列。从输入设备流向内存称为输入操作；从内存流向输入设备称为输出操作。

| 头文件       | 函数和描述                                                   |
| ------------ | ------------------------------------------------------------ |
| \<iostream\> | 该文件定义了 **cin、cout、cerr** 和 **clog** 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流 |
| \<iomanip\>  | 该文件通过所谓的参数化的流操纵器（比如 **setw** 和 **setprecision**），来声明对执行标准化 I/O 有用的服务 |
| \<fstream\>  | 该文件为用户控制的文件处理声明服务                           |

##### 输入

**标准输入流**

cin 是 iostream 类的一个实例，连接到标准输入设备，通常是键盘。

##### 输出

**标准输入流**

cout 是 iostream 类的一个实例，连接到标准输出设备，通常是显示屏。endl 用于在行末添加一个换行符。

**标准错误流**

cerr 是 iostream 类的一个实例，连接到标准输出设备，通常是显示屏。但是 cerr 是非缓冲的，每个流会立即输出。

**标准日志流**

clog 是 iostream 类的一个实例，连接到标准输出设备，通常是显示屏。但是 clong 是缓冲的，每个流会暂时放在缓冲区中，直到缓冲区填满或缓冲区刷新才会输出。

#### 结构

C++数组允许定义存储相同类型的集合，结构允许用户自定义可用的数据类型，是存储不同数据类型的集合。

##### 定义结构

定义结构使用 struct 语句，struct 语句定义了一个包含多个成员变量的新的数据类型。

```c++
struct type_name {
    member_type1 member_name1;
    member_type2 member_name2;
    member_type3 member_name3;
} object_names;
```

 以下声明了一个结构体类型  books，变量为 book。


```c++
struct books {
    char title[50];
    char author[50];
    char subject[50];
    int book_id;
} book;
```

##### 访问结构成员

使用成员访问运算符访问结构的成员。

```c++
int main {
    books novel;
    string title = novel.title;
    return 0;
}
```

##### 结构作为函数参数

```c++
void print_book(struct books);

int main() {
    books novel;
    print_book(novel);
    return 0;
}

void print_book (struct books book) {
    
}
```

##### 指向结构的指针

```c++
struct_pointer = &novel;
string tstruct_pointer -> title;
```



