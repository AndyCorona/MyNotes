#### 前缀树

##### [421. 数组中两个数的最大异或值](https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/)<span id="to421"></span>

```java
/**
   * 获取 int 数的二进制表示
   * 1.构建字典树，将所有的数字的二进制形式加入字典树
   * 2.从字典树根节点开始遍历每个数字 ai，如果 ai 的第 k 位是 0，应该往 1 结点走，否则应该往 0 结点走
   * 3.遍历所有数字之后，返回最大值
   */
public int findMaximumXOR(int[] nums) {
    Trie trie = new Trie();
    int res = 0;
    StringBuilder builder = new StringBuilder();
    //加入前 i 个数字后，第 i + 1 个数字立即去计算异或值
    for (int i = 1; i < nums.length; i++) {
        trie.insert(nums[i - 1]);
        res = Math.max(res, cal(nums[i], trie.root));
        builder.setLength(0);
    }
    return res;
}

private int cal(int num, Trie.TrieNode root) {
    int res = 0;
    for (int i = 30; i >= 0; i--) {
        //从最高位一直取到最低位
        int bit = (num >> i) & 1;
        if (bit == 1) {
            if (root.left != null) {
                root = root.left;
                //注意优先级：res << 1 + 1 == res << 2
                res = (res << 1) + 1;
            } else {
                res = res << 1;
                root = root.right;
            }
        } else if (bit == 0) {
            if (root.right != null) {
                res = (res << 1) + 1;
                root = root.right;
            } else {
                res = res << 1;
                root = root.left;
            }
        }
    }
    return res;
}

class Trie {
    class TrieNode {
        public TrieNode left;
        public TrieNode right;
    }

    public TrieNode root;

    public Trie() {
        root = new TrieNode();
    }

    /**
   * 向前缀树中插入一个 int 二进制数，例如 0000000000000000000000000010110
   * left 为 true 代表 0, right 为 true 代表 1
   */
    public void insert(int number) {
        TrieNode cur = root;
        for (int i = 30; i >= 0; i--) {
            //从最高位一直取到最低位
            int bit = (number >> i) & 1;
            if (bit == 0) {
                if (cur.left != null) {
                    cur = cur.left;
                    continue;
                }
                cur.left = new TrieNode();
                cur = cur.left;
            } else if (bit == 1) {
                if (cur.right != null) {
                    cur = cur.right;
                    continue;
                }
                cur.right = new TrieNode();
                cur = cur.right;
            }
        }
    }
}
```

##### [648. 单词替换](https://leetcode.cn/problems/replace-words/)<span id = "to648"></span>

```java
/**
   * 前缀树：
   * 遍历句子中的每个单词，若单词可以到达一个前缀树末尾（每个词根都有末尾），替换，否则不替换
   */
public String replaceWords(List<String> dictionary, String sentence) {
    Trie trie = new Trie();
    for (String str : dictionary) {
        trie.insert(str);
    }
    String[] split = sentence.split(" ");
    StringBuilder res = new StringBuilder();
    for (String str : split) {
        String successor = trie.isSuccessor(str);
        res.append(successor);
        res.append(" ");
    }
    return res.toString().trim();
}
class Trie {
    class TrieNode {
        public HashMap<Character, TrieNode> dic = new HashMap<>();
        boolean isEnd;
    }

    TrieNode root;

    public Trie() {
        this.root = new TrieNode();
    }

    public void insert(String word) {
        TrieNode cur = root;
        for (char c : word.toCharArray()) {
            if (cur.dic.get(c) == null) {
                cur.dic.put(c, new TrieNode());
            }
            cur = cur.dic.get(c);
        }
        cur.isEnd = true;
    }

    public String isSuccessor(String word) {
        StringBuilder res = new StringBuilder();
        TrieNode cur = root;
        for (char c : word.toCharArray()) {
            if (cur.dic.get(c) == null) {
                break;
            }
            res.append(c);
            cur = cur.dic.get(c);
            //已经到达一个单词末尾，立即跳出
            if (cur.isEnd) {
                return res.toString();
            }
        }
        return cur.isEnd ? res.toString() : word;
    }
}
```

##### [676. 实现一个魔法字典](https://leetcode.cn/problems/implement-magic-dictionary/) <span id="to676"></span>

```java
class MagicDictionary {
    class TrieNode {
        public HashMap<Character, TrieNode> dic = new HashMap<>();
        public boolean isEnd;
    }

    TrieNode root;

    public MagicDictionary() {
        root = new TrieNode();
    }

    public void buildDict(String[] dictionary) {
        for (String str : dictionary) {
            TrieNode cur = root;
            for (char ch : str.toCharArray()) {
                if (cur.dic.get(ch) == null) {
                    cur.dic.put(ch, new TrieNode());
                }
                cur = cur.dic.get(ch);
            }
            cur.isEnd = true;
        }
    }

    public boolean search(String searchWord) {
        return dfs(searchWord, root 0, false);
    }

    public boolean dfs(TrieNode cur, String searchWord, int startIndex, boolean isModified) {
        if (startIndex == searchWord.length()) {
            //必须要修改过且是一个单词
            return isModified && cur.isEnd;
        }
        char c = searchWord.charAt(startIndex);
        if (cur.dic.get(c) != null) {
            //继续匹配下一个字符，后续只要有一种情况返回 true，就返回 true
            if (dfs(cur.dic.get(c), searchWord, startIndex + 1, isModified)) {
                return true;
            }
        }
        //没有修改过的话，尝试修改，后续只要有一种情况返回 true，就返回 true
        if (!isModified) {
            for (Map.Entry<Character, TrieNode> entry : cur.dic.entrySet()) {
                char ch = entry.getKey();
                //不需要和自己再次匹配
                if (cur.dic.get(ch) != null) {
                    if (dfs(cur, searchWord, startIndex + 1, true)) {
                        return true;
                    }
                }
            }
        }
        //所有可能性都匹配完了，只能返回 false
        return false;
    }
}
```

##### [677. 键值映射](https://leetcode.cn/problems/map-sum-pairs/) <span id = "to677"></span>

```java
/**
 * 前缀树
 */
class MapSum {
    class TrieNode {
        public HashMap<Character, TrieNode> dic = new HashMap<>();
        public int value;
    }

    TrieNode root;
    //存放前缀字符串对应的值
    HashMap<String, Integer> map;

    public MapSum() {
        root = new TrieNode();
        map = new HashMap<>();
    }

    public void insert(String key, int val) {
        //例如原本前缀 abc 值为 3，则 a->b->c 的路径上的值都为 3，现在更改为 2，则 delta = -1，a->b->c 路径上的值都应该减 1
        int delta = val - map.getOrDefault(key, 0);
        map.put(key, val);
        TrieNode cur = root;
        for (char ch : key.toCharArray()) {
            if (cur.dic.get(ch) == null) {
                cur.dic.put(ch, new TrieNode());
            }
            cur = cur.dic.get(ch);
            //数值修补
            cur.value += delta;
        }
    }
	//直接获取某个节点的值
    public int sum(String prefix) {
        TrieNode cur = root;
        for (char ch : prefix.toCharArray()) {
            if (cur.dic.get(ch) == null) {
                return 0;
            }
            cur = cur.dic.get(ch);
        }
        return cur.value;
    }
}
```

##### [720. 词典中最长的单词](https://leetcode.cn/problems/longest-word-in-dictionary/)

```java
/**
   * 所有单词加入前缀树，遍历，找到符合条件的最长单词
   */
public String longestWord(String[] words) {
    Trie trie = new Trie();
    for (int i = 0; i < words.length; i++) {
        trie.insert(words[i]);
    }
    String res = "";
    for (int i = 0; i < words.length; i++) {
        String search = trie.search(words[i]);
        if (search != null) {
            //长度相同按照字典序排序
            if (search.length() == res.length()) {
                res = res.compareTo(search) < 0 ? res : search;
            } else if (search.length() > res.length()) {
                res = search;
            }
        }
    } return res;
}

class Trie {
    class TrieNode {
        public TreeMap<Character, TrieNode> dic = new TreeMap<>();
        public boolean isWord;
    }

    TrieNode root;

    public Trie() {
        this.root = new TrieNode();
    }

    public void insert(String word) {
        TrieNode cur = root;
        for (char ch : word.toCharArray()) {
            if (cur.dic.get(ch) == null) {
                cur.dic.put(ch, new TrieNode());
            }
            cur = cur.dic.get(ch);
        }
        cur.isWord = true;
    }

    public String search(String word) {
        TrieNode cur = root;
        for (char ch : word.toCharArray()) {
            if (cur.dic.get(ch) == null) {
                return "";
            }
            cur = cur.dic.get(ch);
            if (!cur.isWord) {
                return "";
            }
        }
        return word;
    }
}
```

##### [792. 匹配子序列的单词数](https://leetcode.cn/problems/number-of-matching-subsequences/)

```java
/**
     * 初始化，构造 26 个桶，每个单词首字母相同的放入同一个桶中
     */
public int numMatchingSubseq(String s, String[] words) {
    //初始化 26 个桶
    ArrayList<Node>[] arr = new ArrayList[26];
    for (int i = 0; i < 26; i++) {
        arr[i] = new ArrayList<Node>();
    }

    //将首字母相同的放入同一个桶中
    for (String str : words) {
        char ch = str.charAt(0);
        arr[ch - 'a'].add(new Node(0, str));
    }

    int res = 0;
    //遍历字符串，找到该字符对应的桶
    for (char ch : s.toCharArray()) {
        ArrayList<Node> bucket = arr[ch - 'a'];
        arr[ch - 'a'] = new ArrayList<>();
        //遍历该桶内所有单词
        for (int i = 0; i < bucket.size(); i++) {
            Node node = bucket.get(i);
            //将该桶内所有单词的索引后移一位 index++，代表所有字符的 index 位及之前的字符已经成功匹配                
            node.index++;
            //当索引走完时，整个单词完全匹配
            if (node.index == node.word.length()) {
                res++;
            } else {
                //新索引的位置作为起始位置，看该索引后的字符是否能匹配，字符被分配到其他桶
                arr[node.word.charAt(node.index) - 'a'].add(node);
            }
        }
        //原有的桶清空
        bucket.clear();
    }
    return res;
}


class Node {
    int index;
    String word;

    public Node(int index, String word) {
        this.index = index;
        this.word = word;
    }
}
```

##### [820. 单词的压缩编码](https://leetcode.cn/problems/short-encoding-of-words/) <span id = "to820"></span>

```java
/**
     * 单词反转后插入字典树
     * 统计所有叶子节点代表的单词长度即为答案
     */
public int minimumLengthEncoding(String[] words) {
    Trie trie = new Trie();
    StringBuilder builder = new StringBuilder();
    for (String str : words) {
        trie.insert(builder.append(str).reverse().toString());
        builder.setLength(0);
    }
    trie.traverse();
    return trie.res;
}

class Trie {
    class TrieNode {
        public HashMap<Character, TrieNode> dic = new HashMap<>();
        public boolean isEnd;
    }

    TrieNode root;

    public Trie() {
        this.root = new TrieNode();
    }

    public void insert(String word) {
        TrieNode cur = root;
        for (char ch : word.toCharArray()) {
            if (cur.dic.get(ch) == null) {
                cur.dic.put(ch, new TrieNode());
            }
            cur = cur.dic.get(ch);
        }
        cur.isEnd = true;
    }

    int res = 0;

    //遍历前缀树，到叶子节点时计算值
    public int traverse() {
        TrieNode cur = root;
        traverse(root, 1);
        return res;
    }

    public void traverse(TrieNode node, int index) {
        if (node.isEnd && node.dic.isEmpty()) {
            res += index;
            return;
        }
        for (Map.Entry<Character, TrieNode> entry : node.dic.entrySet()) {
            char ch = entry.getKey();
            traverse(node.dic.get(ch), index + 1);
        }
    }
}
```

##### [1233. 删除子文件夹](https://leetcode.cn/problems/remove-sub-folders-from-the-filesystem/)

```java
/**
     * 前缀树，节点保存一层目录的目录名
     */
public List<String> removeSubfolders(String[] folder) {
    Trie trie = new Trie();
    //建树
    for (String i : folder) {
        trie.add(i);
    }
    //遍历所有字符串
    List<String> ans = new ArrayList<>();
    for (String i : folder) {
        if (trie.search(i)) {
            ans.add(i);
        }
    }
    return ans;
}
}

class Trie {
    HashMap<String, Trie> child;
    boolean isEnd;

    public Trie() {
        this.child = new HashMap<>();
        this.isEnd = false;
    }

    public void add(String s) {
        Trie root = this;
        String[] arr = s.split("/");
        for (int i = 0; i < arr.length; i++) {
            if (!root.child.containsKey(arr[i])) {
                root.child.put(arr[i], new Trie());
            }
            root = root.child.get(arr[i]);
        }
        root.isEnd = true;
    }

    public boolean search(String s) {
        Trie root = this;
        String[] arr = s.split("/");
        for (int i = 0; i < arr.length; i++) {
            root = root.child.get(arr[i]);
            // /a/b 还未到达末尾的时候 root.isEnd = true 说明 /a 存在，所以 /a/b 是子目录
            if (i != arr.length - 1 && root.isEnd) {
                return false;
            }
        }
        return true;
    }
```

##### [1268. 搜索推荐系统](https://leetcode.cn/problems/search-suggestions-system/)

```java
/**
* 前缀树+DFS
*/
public List<List<String>> suggestedProducts(String[] products, String searchWord) {
    List<List<String>> res = new ArrayList<>();
    Trie trie = new Trie();
    //建树
    for (String str : products) {
        trie.add(str);
    }
    //所有可能的输入字符串
    for (int i = 1; i <= searchWord.length(); i++) {
        String subStr = searchWord.substring(0, i);
        List<String> search = trie.search(subStr);
        res.add(search);
    }
    return res;
}
class Trie {

    class TrieNode {
        TreeMap<Character, TrieNode> child = new TreeMap<>();
        boolean isEnd;
    }

    TrieNode root;

    public Trie() {
        root = new TrieNode();
    }

    public void add(String s) {
        TrieNode cur = root;
        for (char ch : s.toCharArray()) {
            if (cur.child.get(ch) == null) {
                cur.child.put(ch, new TrieNode());
            }
            cur = cur.child.get(ch);
        }
        cur.isEnd = true;
    }
	
    public List<String> search(String s) {
        TrieNode cur = root;
        List<String> list = new ArrayList<>();
        dfs(s, 0, root, list, new StringBuilder());
        return list;
    }

    //输入一个字符串，dfs 前缀树
    public void dfs(String s, int startIndex, TrieNode cur, List<String> list, StringBuilder builder) {
        //已经获取三个相关单词
        if (list.size() == 3) {
            return;
        }
        //输入 abc，获取 abcd 的字符串，长度必须大于输入字符串
        if (cur.isEnd && startIndex >= s.length()) {
            list.add(builder.toString());
        }
        //前缀树遍历 base case
        if (cur.child.isEmpty()) {
            return;
        }
       	//多叉树，需要过滤
        for (Map.Entry<Character, TrieNode> entry : cur.child.entrySet()) {
            char ch = entry.getKey();
            //过滤 key
            if (startIndex >= s.length() || ch == s.charAt(startIndex)) {
                builder.append(ch);
                dfs(s, startIndex + 1, cur.child.get(ch), list, builder);
                builder.setLength(builder.length() - 1);
            }
        }
    }
}
```

##### [剑指 Offer II 063. 替换单词](https://leetcode.cn/problems/UhWRSj/)

leetcode -> [648. 单词替换](#to648)

##### [剑指 Offer II 065. 最短的单词编码](https://leetcode.cn/problems/iSwD2y/)

leetcoed -> [820. 单词的压缩编码](#to820)

##### [剑指 Offer II 066. 单词之和](https://leetcode.cn/problems/z1R5dt/)

leetcode -> [剑指 Offer II 066. 单词之和](#to677)

##### [剑指 Offer II 064. 神奇的字典](https://leetcode.cn/problems/US1pGT/)

leetcode -> [676. 实现一个魔法字典](#to676)

##### [剑指 Offer II 067. 最大的异或](https://leetcode.cn/problems/ms70jA/)

leetcode -> [421. 数组中两个数的最大异或值](#to421)

##### [面试题 16.02. 单词频率](https://leetcode.cn/problems/words-frequency-lcci/)

```		java
class WordsFrequency {
    HashMap<String, Integer> dic = new HashMap<>();

    public WordsFrequency(String[] book) {
        for (String str : book) {
            dic.put(str, dic.getOrDefault(str, 0) + 1);
        }
    }
    
    public int get(String word) {
         return dic.getOrDefault(word, 0);
    }
}
```

##### [面试题 17.17. 多次搜索](https://leetcode.cn/problems/multi-search-lcci/)

```java
public int[][] multiSearch(String big, String[] smalls) {
    TrieNode root = new TrieNode();
    Map<String, List<Integer>> map = new HashMap<>();
    //将短字符串反转后构建字典树
    for (String small : smalls) {
        map.put(small, new ArrayList<>());
        insert(root, small);
    }
    //寻找所有单词在big中的起始位置，并存放在map中
    for (int i = 0; i < big.length(); i++) {
        search(root, i, big, map);
    }
    //输出结果
    int[][] ans = new int[smalls.length][];
    for (int i = 0; i < smalls.length; i++) {
        ans[i] = map.get(smalls[i]).stream().mapToInt(Integer::valueOf).toArray();
    }
    return ans;
}

//构建后缀树
public void insert(TrieNode root, String word) {
    TrieNode cur = root;
    //倒序插入前缀树
    for (int i = word.length() - 1; i >= 0; i--) {
        char ch = word.charAt(i);
        if (cur.child.get(ch) == null) {
            cur.child.put(ch, new TrieNode());
        }
        cur = cur.child.get(ch);
    }
    cur.isWord = true; //表示单词的结尾
}

//寻找以endPos结尾的所有单词的起始位置
public void search(TrieNode root, int endPos, String sentence, Map<String, List<Integer>> map) {
    TrieNode cur = root;
    StringBuilder builder = new StringBuilder(); //单词作为key
    for (int i = endPos; i >= 0; i--) {
        char ch = sentence.charAt(i);
        if (cur.child.get(ch) == null) {
            break;
        }
        //由于字典树存的是后缀，故要倒着插入
        builder.insert(0, sentence.charAt(i));
        //往后寻找
        cur = cur.child.get(ch);
        //找到某个单词，就把起始位置添加到map中
        if (cur.isWord) {
            map.get(builder.toString()).add(i);
        }
    }
}

class TrieNode {
    HashMap<Character, TrieNode> child;
    boolean isWord;

    public TrieNode() {
        child = new HashMap();
    }
}
```

#### BFS

##### [111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

```java
/**
* 层序遍历，遇到第一个左右子结点都为 null 的节点即为最小深度
*/
public int minDepth(TreeNode root) {

    if (root == null) {
        return 0;
    }

    LinkedList<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int index = 1;
    while (!queue.isEmpty()) {
        int sz = queue.size();
        for (int i = 0; i < sz; i++) {
            TreeNode cur = queue.poll();
            if (cur.left == null && cur.right == null) {
                return index;
            }
            if (cur.left != null) {
                queue.offer(cur.left);
            }
            if (cur.right != null) {
                queue.offer(cur.right);
            }
        }
        index++;
    }
    return 0;
}
```

##### [637. 二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)

```java
public List<Double> averageOfLevels(TreeNode root) {
    LinkedList<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    List<Double> list = new ArrayList<>();
    while (!queue.isEmpty()) {
        int sz = queue.size();
        double sum = 0;
        for (int i = 0; i < sz; i++) {
            TreeNode poll = queue.poll();
            sum += poll.val;
            if (poll.left != null) {
                queue.offer(poll.left);
            }
            if (poll.right != null) {
                queue.offer(poll.right);
            }
        }
        list.add(sum / sz);
    }
    return list;
}
```

##### [993. 二叉树的堂兄弟节点](https://leetcode.cn/problems/cousins-in-binary-tree/)

```java
/**
     * BFS，获取两个节点的父节点和层级，判断即可
     */
public boolean isCousins(TreeNode root, int x, int y) {
    if (root == null) {
        return false;
    }
    int heightX = 0;
    int heightY = 0;
    TreeNode levelX = null;
    TreeNode levelY = null;
    int level = 1;
    LinkedList<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        int sz = queue.size();
        for (int i = 0; i < sz; i++) {
            TreeNode poll = queue.poll();
            if (poll.left != null) {
                queue.offer(poll.left);
                if (poll.left.val == x) {
                    heightX = level;
                    levelX = poll;
                }
                if (poll.left.val == y) {
                    heightY = level;
                    levelY = poll;
                }
            }
            if (poll.right != null) {
                queue.offer(poll.right);
                if (poll.right.val == x) {
                    heightX = level;
                    levelX = poll;
                }
                if (poll.right.val == y) {
                    heightY = level;
                    levelY = poll;
                }
            }
        }
        if (levelX != null && levelY != null) {
            break;
        }
        level++;
    }
    return (heightX == heightY) && (levelX != levelY);
}
```

##### [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

```java
/**
* 层序遍历模板
*/
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> res = new LinkedList<>();
    if (root == null) {
        return res;
    }
    LinkedList<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        int sz = queue.size();
        List<Integer> temp = new LinkedList<>();
        for (int i = 0; i < sz; i++) {
            TreeNode cur = queue.poll();
            temp.add(cur.val);
            if (cur.left != null) {
                queue.offer(cur.left);
            }
            if (cur.right != null) {
                queue.offer(cur.right);
            }
        }
        res.add(temp);
    }
    return res;
}
```

[103. 二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)

```java
/**
     * BFS，给层加上编号，根据编号从左到右或从右到左加入集合
     */
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
    List<List<Integer>> res = new LinkedList<>();
    if (root == null) {
        return res;
    }
    LinkedList<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int index = 0;
    while (!queue.isEmpty()) {
        int sz = queue.size();
        LinkedList<Integer> temp = new LinkedList<>();
        for (int i = 0; i < sz; i++) {
            TreeNode cur = queue.poll();
            if (index % 2 == 0) {
                temp.addLast(cur.val);
            } else {
                temp.addFirst(cur.val);
            }
            if (cur.left != null) {
                queue.offer(cur.left);
            }
            if (cur.right != null) {
                queue.offer(cur.right);
            }
        }
        index++;
        res.add(temp);
    }
    return res;
}
```

##### [107. 二叉树的层序遍历 II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

```java
/**
     * 可以使用 linkedlist 的 addFirst 进行头插法
     * 也可以使用 arraylist 的 add(index,value) 进行头插法，但注意不要越界
     */
public List<List<Integer>> levelOrderBottom(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();
    if (root == null) {
        return res;
    }
    LinkedList<TreeNode> queue = new LinkedList<>();
    while (!queue.isEmpty()) {
        int sz = queue.size();
        List<Integer> temp = new ArrayList<>();
        for (int i = 0; i < sz; i++) {
            TreeNode cur = queue.poll();
            temp.add(cur.val);
            if (cur.left != null) {
                queue.offer(cur.left);
            }

            if (cur.right != null) {
                queue.offer(cur.right);
            }
        }
        res.add(0, temp);
    }
    return res;
}
```

##### [116. 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

```java
/**
     * 层序遍历
     */
public Node connect(Node root) {
    if (root == null) {
        return null;
    }
    LinkedList<Node> queue = new LinkedList<>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        int sz = queue.size();
        Node pre = null;
        for (int i = 0; i < sz; i++) {
            Node cur = queue.poll();
            if (pre != null) {
                pre.next = cur;
            }
            pre = cur;
            if (cur.left != null) {
                queue.offer(cur.left);
            }
            if (cur.right != null) {
                queue.offer(cur.right);
            }
        }
    }
    return root;
}
```

##### [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

```java
/**
   * 层序遍历，每层的最后一个结点加入集合
   */
public List<Integer> rightSideView(TreeNode root) {
    List<Integer> res = new LinkedList<>();
    if (root == null) {
        return res;
    }
    LinkedList<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        int sz = queue.size();
        for (int i = 0; i < sz; i++) {
            TreeNode cur = queue.poll();
            if (i == sz - 1) {
                res.add(cur.val);
            }
            if (cur.left != null) {
                queue.offer(cur.left);
            }
            if (cur.right != null) {
                queue.offer(cur.right);
            }
        }
    }
    return res;
}
```

##### [210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/)

```java
/**
   * bfs 判断有向图是否有环
   * 将所有入度为 0 的结点加入队列后，bfs 中计算出队个数，若出队个数和元素个数不相同，则有环
   */
public int[] findOrder(int numCourses, int[][] prerequisites) {
    int count = 0;
    int[] res = new int[numCourses];
    //计算一个结点的入度，当存在环时，入度可能小于 0
    int[] inDegree = new int[numCourses];
    LinkedList<Integer> queue = new LinkedList<>();
    List<List<Integer>> graph = new ArrayList<>();
    for (int i = 0; i < numCourses; i++) {
        graph.add(new ArrayList<>());
    }
    //创建邻接表
    for (int i = 0; i < prerequisites.length; i++) {
        int from = prerequisites[i][1];
        int to = prerequisites[i][0];
        inDegree[to]++;
        graph.get(from).add(to);
    }
    //找到所有入度为 0 的结点，加入队列
    for (int i = 0; i < inDegree.length; i++) {
        if (inDegree[i] == 0) {
            queue.offer(i);
        }
    }
    while (!queue.isEmpty()) {
        int num = queue.poll();
        res[count] = num;
        count++;
        List<Integer> list = graph.get(num);
        for (int next : list) {
            inDegree[next]--;
            //只有一个结点入度为 0 才可以加入队列，入度为 0 说明该结点的所有上层结点已经走完，且该节点不存在环
            if (inDegree[next] == 0) {
                queue.offer(next);
            }
        }
    }
    if (count != numCourses) {
        return new int[0];
    }
    return res;
}
```

##### [310. 最小高度树](https://leetcode.cn/problems/minimum-height-trees/)

```java
/**
   * BFS: 找到距离节点 0 的最远节点 x，然后找到距离节点 x 的最远节点 y，然后找到节点 x 与节点 y 的路径，中点即为最小高度树的结点
    */
List<List<Integer>> graph;
List<Integer> res;
public List<Integer> findMinHeightTrees(int n, int[][] edges) {
    graph = new ArrayList<>();
    res = new ArrayList<>();
    for (int i = 0; i < n; i++) {
        graph.add(new ArrayList<>());
    }
    //构建邻接链表
    for (int i = 0; i < edges.length; i++) {
        int vertex1 = edges[i][0];
        int vertex2 = edges[i][1];
        graph.get(vertex1).add(vertex2);
        graph.get(vertex2).add(vertex1);
    }
    //顺便记录一个结点的父节点，方便通过一个结点达到另一个结点
    int[] parent = new int[n];
    Arrays.fill(parent, -1);
    //寻找离一个结点最远的另一个结点 x
    int x = findLongest(n, 0, parent);
    //寻找离 x 结点最远的另一个 y 结点
    int y = findLongest(n, x, parent);
    //获取 x 和 y 经过的结点，最小生成树的根节点一定在路径中间
    List<Integer> path = new ArrayList<>();
    parent[x] = -1;
    while (y != -1) {
        path.add(y);
        y = parent[y];
    }
    int size = path.size();
    //偶数返回两个结点
    if (size % 2 == 0) {
        res.add(path.get(size / 2 - 1));
    }
    res.add(path.get(size / 2));
    return res;
}

private int findLongest(int n, int k, int[] parent) {
    LinkedList<Integer> queue = new LinkedList<>();
    queue.offer(k);
    boolean[] isVisited = new boolean[n];
    int node = -1;
    isVisited[k] = true;
    while (!queue.isEmpty()) {
        int poll = queue.poll();
        node = poll;
        List<Integer> list = graph.get(poll);
        for (int num : list) {
            if (isVisited[num]) {
                continue;
            }
            isVisited[num] = true;
            parent[num] = poll;
            queue.offer(num);
        }
    }
    return node;
}
```

##### [429. N 叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)

```java
public List<List<Integer>> levelOrder(Node root) {
    List<List<Integer>> res = new ArrayList<>();
    if (root == null) {
        return res;
    }
    LinkedList<Node> queue = new LinkedList<>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        int sz = queue.size();
        List<Integer> temp = new ArrayList<>();
        for (int i = 0; i < sz; i++) {
            Node cur = queue.poll();
            temp.add(cur.val);
            for (int j = 0; j < cur.children.size(); j++) {
                Node child = cur.children.get(j);
                if (child != null) {
                    queue.offer(child);
                }
            }
        }
        res.add(temp);
    }
    return res;
}
```

##### [433. 最小基因变化](https://leetcode.cn/problems/minimum-genetic-mutation/)

```java
/**
     * BFS: 每次变化一个字符，看是否合法，记录变化次数直到达到需要的字符串
     */
public int minMutation(String start, String end, String[] bank) {
    Set<String> record = new HashSet<>();
    char[] key = {'A', 'C', 'G', 'T'};
    for (String str : bank) {
        record.add(str);
    }
    if (!record.contains(end)) {
        return -1;
    }
    if (start == end) {
        return 0;
    }
    LinkedList<String> queue = new LinkedList<>();
    //记录一个合法字符串是否访问过
    Set<String> isVisited = new HashSet<>();
    queue.offer(start);
    isVisited.add(start);
    int step = 1;
    while (!queue.isEmpty()) {
        int sz = queue.size();
        for (int i = 0; i < sz; i++) {
            String cur = queue.poll();
            //字符串长度为 8
            for (int j = 0; j < 8; j++) {
                //每个字符可以变化三次
                for (int k = 0; k < 4; k++) {
                    //相同字符跳过
                    if (key[k] == cur.charAt(j)) {
                        continue;
                    }
                    StringBuilder temp = new StringBuilder();
                    temp.append(cur);
                    //更改某一位的字符
                    temp.setCharAt(j, key[k]);
                    String str = temp.toString();
                    //若更改后的字符合法且未访问过
                    if (!record.contains(str) || isVisited.contains(str)) {
                        continue;
                    }
                    //更改后的字符等于最终字符，直接返回
                    if (str.equals(end)) {
                        return step;
                    }
                    isVisited.add(str);
                    queue.offer(str);
                }
            }
        }
        step++;
    }
    return -1;
}
```

##### [513. 找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/)

```java
public int findBottomLeftValue(TreeNode root) {
    LinkedList<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int res = 0;
    while (!queue.isEmpty()) {
        int sz = queue.size();
        for (int i = 0; i < sz; i++) {
            TreeNode cur = queue.poll();
            if (i == 0) {
                res = cur.val;
            }
            if (cur.left != null) {
                queue.offer(cur.left);
            }
            if (cur.right != null) {
                queue.offer(cur.right);
            }
        }
    }
    return res;
}
```

##### [515. 在每个树行中找最大值](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)

```java
public List<Integer> largestValues(TreeNode root) {
    List<Integer> res = new LinkedList<>();
    if (root == null) {
        return res;
    }
    LinkedList<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        int sz = queue.size();
        int value = Integer.MIN_VALUE;
        for (int i = 0; i < sz; i++) {
            TreeNode cur = queue.poll();
            value = Math.max(value, cur.val);
            if (cur.left != null) {
                queue.offer(cur.left);
            }
            if (cur.right != null) {
                queue.offer(cur.right);
            }
        }
        res.add(value);
    }
    return res;
}
```

##### [623. 在二叉树中增加一行](https://leetcode.cn/problems/add-one-row-to-tree/)

```java
/**
     * 层序遍历
     * 特殊情况：第一层插入
     * 一般情况：要插入第 i 层，在第 i - 1 层时获取 i- 1 的所有节点，断开和下一层的联系，新建节点，重新建立联系
     */
public TreeNode addOneRow(TreeNode root, int val, int depth) {
    //第一层的特判
    if (depth == 1) {
        TreeNode newRoot = new TreeNode(val);
        newRoot.left = root;
        return newRoot;
    }
    LinkedList<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int index = 1;
    while (!queue.isEmpty()) {
        int sz = queue.size();
        for (int i = 0; i < sz; i++) {
            TreeNode cur = queue.poll();
            TreeNode left = cur.left;
            TreeNode right = cur.right;
            //要插入到第 i 层，在第 i - 1 层时行动
            if (depth == index + 1) {
                //断开原本层之间的联系，新建插入层与上一层的联系
                cur.left = new TreeNode(val);
                //新建插入层与下一层的联系
                cur.left.left = left;
                cur.right = new TreeNode(val);
                cur.right.right = right;
            }
            if (left != null) {
                queue.offer(left);
            }
            if (right != null) {
                queue.offer(right);
            }
        }
        index++;
        //插入完毕，跳出，后续无需处理
        if(depth == index) {
            break;
        }
    }
    return root;
}
```

##### [655. 输出二叉树](https://leetcode.cn/problems/print-binary-tree/)

```java
/**
     * BFS + 模拟
     * 获取树最大深度，创建数组后，BFS 遍历填充值返回
     */
private int maxDepth = 0;

public List<List<String>> printTree(TreeNode root) {
    maxDepth(root, -1);
    List<List<String>> res = new ArrayList<>();
    //按照题目规则创建数组
    int n = (int) (Math.pow(2, (maxDepth + 1)) - 1);
    for (int i = 0; i < maxDepth + 1; i++) {
        res.add(new ArrayList<>());
        for (int j = 0; j < n; j++) {
            res.get(i).add("");
        }
    }
    //层序遍历，将节点及其要填入的坐标信息封装成 Info 类
    LinkedList<InfoNode> queue = new LinkedList<>();
    //根节点填入的左边为 0, (n-1) / 2，其他节点坐标都可以根据根节点的坐标推算出
    queue.offer(new InfoNode(root, 0, (n - 1) / 2));
    while (!queue.isEmpty()) {
        int sz = queue.size();
        for (int i = 0; i < sz; i++) {
            InfoNode cur = queue.poll();
            int x = cur.x;
            int y = cur.y;
            //获取节点左边，在数组相应位置上填充节点的值
            res.get(x).set(y, String.valueOf(cur.node.val));
            int temp = (int) Math.pow(2, maxDepth - x - 1);
            //根据当前节点，设置左右节点的坐标
            if (cur.node.left != null) {
                queue.offer(new InfoNode(cur.node.left, x + 1, y - temp));
            }
            if (cur.node.left != null) {
                queue.offer(new InfoNode(cur.node.right, x + 1, y + temp));
            }
        }
    }
    return res;
}

class InfoNode {
    private TreeNode node;
    private int x;
    private int y;

    public InfoNode(TreeNode node, int x, int y) {
        this.node = node;
        this.x = x;
        this.y = y;
    }
}
```

##### [662. 二叉树最大宽度](https://leetcode.cn/problems/maximum-width-of-binary-tree/)

```java
/**
     * BFS，给根节点编号 1，左子结点编号 2 * i，右子结点编号 2 * i + 1
     * 通过编号确定最大宽度
     */
public int widthOfBinaryTree(TreeNode root) {
    int res = 0;
    LinkedList<InfoNode> queue = new LinkedList<>();
    queue.offer(new InfoNode(root, 1));
    while (!queue.isEmpty()) {
        int sz = queue.size();
        int start = 0;
        int end = 0;
        for (int i = 0; i < sz; i++) {
            InfoNode cur = queue.poll();
            if (i == 0) {
                start = cur.number;
            }
            if (i == sz - 1) {
                end = cur.number;
            }
            if (cur.node.left != null) {
                queue.offer(new InfoNode(cur.node.left, cur.number * 2));
            }
            if (cur.node.right != null) {
                queue.offer(new InfoNode(cur.node.right, cur.number * 2 + 1));
            }
        }
        res = Math.max(res, end - start + 1);
    }
    return res;
}

class InfoNode {
    TreeNode node;
    int number;

    public InfoNode(TreeNode node, int number) {
        this.node = node;
        this.number = number;
    }
}
```

##### [752. 打开转盘锁](https://leetcode.cn/problems/open-the-lock/)

```java
/**
     * BFS：每次更改一个字符，第一层更改一个字符的所有可能情况，第二层在第一层的基础上继续更改一个字符的所有情况，最终返回层数即操作步数
     */
public int openLock(String[] deadends, String target) {
    if ("0000".equals(target)) {
        return 0;
    }
    HashSet<String> set = new HashSet<>();
    for (String str : deadends) {
        set.add(str);
    }
    if(set.contains("0000")) {
        return -1;
    }
    //防止重复，例如 0000 -> 0010 -> 0000
    HashSet<String> isVisited = new HashSet<>();
    int step = 1;
    LinkedList<String> queue = new LinkedList<>();
    queue.offer("0000");
    isVisited.add("0000");
    while (!queue.isEmpty()) {
        int sz = queue.size();
        for (int i = 0; i < sz; i++) {
            String cur = queue.poll();
            //共有 4 个字符，旋转一位时任意一个位置都可以旋转一次
            for (int j = 0; j < 4; j++) {
                List<String> scroll = scroll(cur, j);
                for (String str : scroll) {
                    //旋转后的字符串合法且未访问过
                    if (!set.contains(str) && !isVisited.contains(str)) {
                        if (str.equals(target)) {
                            return step;
                        }
                        isVisited.add(str);
                        queue.offer(str);
                    }
                }
            }
        }
        step++;
    }
    return-1;
}

//每次只能在任意一个位置旋转一位数字
private List<String> scroll(String input, int index) {
    List<String> list = new LinkedList<>();
    StringBuilder res = new StringBuilder();
    res.append(input);
    char ch = input.charAt(index);
    //向上旋转
    if (ch == '9') {
        res.setCharAt(index, '0');
    } else {
        res.setCharAt(index, (char) (ch + 1));
    }
    list.add(res.toString());
    res.setLength(0);
    res.append(input);
    //向下旋转
    if (ch == '0') {
        res.setCharAt(index, '9');
    } else {
        res.setCharAt(index, (char) (ch - 1));
    }
    list.add(res.toString());
    return list;
}
```

##### [863. 二叉树中所有距离为 K 的结点](https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/)

```java
/**
     * 将树看作图，从 target 开始 bfs，即向父节点、两个子结点 bfs 扩散
     * 但向父节点扩散需要获取该节点的父节点信息，需要遍历树记录节点与父节点的映射
     */
HashMap<TreeNode, TreeNode> dic = new HashMap<>();
public List<Integer> distanceK(TreeNode root, TreeNode target, int k) {
    List<Integer> res = new ArrayList<>();
    traverse(root, null);
    HashSet<TreeNode> isVisited = new HashSet<>();
    LinkedList<TreeNode> queue = new LinkedList<>();
    queue.offer(target);
    isVisited.add(target);
    while (!queue.isEmpty()) {
        int sz = queue.size();
        for (int i = 0; i < sz; i++) {
            TreeNode cur = queue.poll();
            if (k == 0) {
                res.add(cur.val);
            }
            //获取父节点，没访问过的
            if (dic.get(cur) != null && !isVisited.contains(dic.get(cur))) {
                isVisited.add(dic.get(cur));
                queue.offer(dic.get(cur));
            }
            //获取两个子结点，没访问过的
            if (cur.left != null && !isVisited.contains(cur.left)) {
                isVisited.add(cur.left);
                queue.offer(cur.left);
            }
            if (cur.right != null && !isVisited.contains(cur.right)) {
                isVisited.add(cur.right);
                queue.offer(cur.right);
            }
        }
        k--;
        if (k < 0) {
            break;
        }
    }
    return res;
}
//构建节点与父节点的映射
public void traverse(TreeNode root, TreeNode parent) {
    if (root == null) {
        return;
    }
    dic.put(root, parent);
    traverse(root.left, root);
    traverse(root.right, root);
}
```

##### [919. 完全二叉树插入器](https://leetcode.cn/problems/complete-binary-tree-inserter/)

```java
class CBTInserter {

    private TreeNode root;
    private LinkedList<TreeNode> queue;

    public CBTInserter(TreeNode root) {
        this.root = root;
        queue = new LinkedList<>();
        LinkedList<TreeNode> temp = new LinkedList<>();
        temp.offer(root);
        while (!temp.isEmpty()) {
            TreeNode cur = temp.poll();
            if (cur.left != null) {
                temp.offer(cur.left);
            }
            if (cur.right != null) {
                temp.offer(cur.right);
            }
            //记录可以插入的结点
            if (cur.left == null || cur.right == null) {
                queue.offer(cur);
            }
        }
    }

    public int insert(int val) {
        TreeNode newNode = new TreeNode(val);
        //获取可以插入的结点
        TreeNode cur = queue.peek();
        if (cur.left == null) {
            cur.left = newNode;
        } else if (cur.right == null) {
            //插入右结点后，当前结点不能再插入，该删除
            cur.right = newNode;
            queue.poll();
        }
        //新插入的结点也可以插入子结点
        queue.offer(newNode);
        return cur.val;
    }

    public TreeNode get_root() {
        return root;
    }
}
```

##### [934. 最短的桥](https://leetcode.cn/problems/shortest-bridge/)

```java
/**
     * 先 DFS 一次，再 BFS
     */
int[] positionX = new int[]{-1, 1, 0, 0};
int[] positionY = new int[]{0, 0, 1, -1};
public int shortestBridge(int[][] grid) {
    int m = grid.length;
    int n = grid[0].length;
    LinkedList<int[]> queue = new LinkedList<>();
    label: for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == 1) {
                dfs(grid, i, j, queue);
                break label;
            }
        }
    }
    int res = 0;
    while (!queue.isEmpty()) {
        res++;
        int sz = queue.size();
        for (int i = 0; i < sz; i++) {
            int[] curr = queue.poll();
            int x = curr[0];
            int y = curr[1];
            for (int k = 0; k < 4; k++) {
                int newX = x + positionX[k];
                int newY = y + positionY[k];
                if (newX < 0 || newX >= grid.length || newY < 0 || newY >= grid[0].length || grid[newX][newY] == 2) {
                    continue;
                }
                if (grid[newX][newY] == 1) return res;
                queue.offer(new int[]{newX, newY});
                grid[newX][newY] = 2;
            }
        }
    }
    return res;
}

private void dfs(int[][] grid, int x, int y, LinkedList<int[]> queue) {
    grid[x][y] = 2;
    for (int k = 0; k < 4; k++) {
        int newX = x + positionX[k];
        int newY = y + positionY[k];
        // 越界或已访问
        if (newX < 0 || newX >= grid.length || newY < 0 || newY >= grid[0].length || grid[newX][newY] == 2) {
            continue;
        }
        // 收集周围的水域
        if (grid[newX][newY] == 0) {
            queue.offer(new int[]{newX, newY});
            continue;
        }
        dfs(grid, newX, newY, queue);
    }
}
```

##### [958. 二叉树的完全性检验](https://leetcode.cn/problems/check-completeness-of-a-binary-tree/)

```java
/**
     * 结点编号：两个结点之间编号不能大于 1
     */
public boolean isCompleteTree(TreeNode root) {
    LinkedList<InfoNode> queue = new LinkedList<>();
    queue.offer(new InfoNode(root, 1));
    int pre = 0;
    while (!queue.isEmpty()) {
        InfoNode cur = queue.poll();
        if (cur.value - pre > 1) {
            return false;
        }
        pre = cur.value;
        if (cur.node.left != null) {
            queue.offer(new InfoNode(cur.node.left, cur.value * 2));
        }
        if (cur.node.right != null) {
            queue.offer(new InfoNode(cur.node.right, cur.value * 2 + 1));
        }
    }
    return true;
}

class InfoNode {
    TreeNode node;
    int value;

    public InfoNode(TreeNode node, int value) {
        this.node = node;
        this.value = value;
    }
}

```

##### [994. 腐烂的橘子](https://leetcode.cn/problems/rotting-oranges/)

```java
/**
   * 多源 BFS，一开始将所有腐烂橘子入队
   */
int[] positionX = new int[]{-1, 1, 0, 0};
int[] positionY = new int[]{0, 0, 1, -1};

public int orangesRotting(int[][] grid) {
    LinkedList<int[]> queue = new LinkedList<>();
    int fresh = 0;
    int corrupt = 0;
    int m = grid.length;
    int n = grid[0].length;
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == 2) {
                queue.offer(new int[]{i, j});
                grid[i][j] = 2;
                corrupt++;
            } else if (grid[i][j] == 1) {
                fresh++;
            }
        }
    }
    int minute = -1;
    while (!queue.isEmpty()) {
        int sz = queue.size();
        for (int i = 0; i < sz; i++) {
            int[] position = queue.poll();
            int x = position[0];
            int y = position[1];
            for (int j = 0; j < 4; j++) {
                int newX = positionX[j] + x;
                int newY = positionY[j] + y;
                if (newX >= 0 && newX < grid.length && newY >= 0 && newY < grid[0].length && grid[newX][newY] == 1) {
                    fresh--;
                    queue.offer(new int[]{newX, newY});
                    grid[newX][newY] = 2;
                }
            }
        }
        minute++;
    }
    //还有新鲜橘子，返回 -1，没有腐烂的水果，返回 0
    return fresh != 0 ? -1 : corrupt == 0 ? 0 : minute;
}
```

##### [1020. 飞地的数量](https://leetcode.cn/problems/number-of-enclaves/)

```java
/**
   * 多源 BFS，先将边界的所有 1 加入队列，后通过 BFS 将所有和边界 1 相连的 1 改为 0，最后统计矩阵中剩余 1 的个数
   */
int[] positionX = new int[]{-1, 1, 0, 0};
int[] positionY = new int[]{0, 0, -1, 1};
public int numEnclaves(int[][] grid) {
    int m = grid.length;
    int n = grid[0].length;
    LinkedList<int[]> queue = new LinkedList<>();
    //寻找边界的 1
    for (int i = 0; i < m; i++) {
        if (grid[i][0] == 1) {
            grid[i][0] = 0;
            queue.offer(new int[]{i, 0});
        }
        if (grid[i][n - 1] == 1) {
            grid[i][n - 1] = 0;
            queue.offer(new int[]{i, n - 1});
        }
    }
    //寻找边界的 
    for (int i = 1; i < n - 1; i++) {
        if (grid[0][i] == 1) {
            grid[0][i] = 0;
            queue.offer(new int[]{0, i});
        }
        if (grid[m - 1][i] == 1) {
            grid[m - 1][i] = 0;
            queue.offer(new int[]{m - 1, i});
        }
    }
    while (!queue.isEmpty()) {
        int[] position = queue.poll();
        int x = position[0];
        int y = position[1];
        for (int i = 0; i < 4; i++) {
            int newX = x + positionX[i];
            int newY = y + positionY[i];
            if (newX < 0 || newX >= grid.length || newY < 0 || newY >= grid[0].length || grid[newX][newY] == 0) {
                continue;
            }
            grid[newX][newY] = 0;
            queue.offer(new int[]{newX, newY});
        }
    }
    int res = 0;
    for (int i = 1; i < m - 1; i++) {
        for (int j = 1; j < n - 1; j++) {
            if (grid[i][j] == 1) {
                res++;
            }
        }
    }
    return res;
}
```

##### [1091. 二进制矩阵中的最短路径](https://leetcode.cn/problems/shortest-path-in-binary-matrix/)

```java
/**
     * BFS，每次可以走八个方向
     */
int[] positionX = new int[]{-1, 1, 0, 0, 1, -1, 1, -1};
int[] positionY = new int[]{0, 0, -1, 1, 1, -1, -1, 1};

public int shortestPathBinaryMatrix(int[][] grid) {
    int m = grid.length;
    //特判
    if (grid[0][0] != 0 || grid[m - 1][m - 1] != 0) {
        return -1;
    }
    //特判
    if (m == 1 && grid[m - 1][m - 1] == 0) {
        return 1;
    }
    LinkedList<int[]> queue = new LinkedList<>();
    queue.offer(new int[]{0, 0});
    grid[0][0] = 1;
    int step = 1;
    while (!queue.isEmpty()) {
        step++;
        int sz = queue.size();
        for (int i = 0; i < sz; i++) {
            int[] position = queue.poll();
            int x = position[0];
            int y = position[1];
            for (int j = 0; j < 8; j++) {
                int newX = x + positionX[j];
                int newY = y + positionY[j];
                if (newX < 0 || newX >= grid.length || newY < 0 || newY >= grid[0].length || grid[newX][newY] == 1) {
                    continue;
                }
                if (newX == m - 1 && newY == m - 1) {
                    return step;
                }
                grid[newX][newY] = 1;
                queue.offer(new int[]{newX, newY});
            }
        }
    }
    return -1;
}

```

##### [1162. 地图分析](https://leetcode.cn/problems/as-far-from-land-as-possible/)

```java
/**
     * 多源 BFS
     */
int[] positionX = new int[]{1, -1, 0, 0,};
int[] positionY = new int[]{0, 0, -1, 1};

public int maxDistance(int[][] grid) {
    boolean isAllOcean = true;
    boolean isAllLand = true;
    int m = grid.length;
    int n = grid[0].length;
    LinkedList<int[]> queue = new LinkedList<>();
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == 1) {
                queue.offer(new int[]{i, j});
                isAllOcean = false;
            } else if (grid[i][j] == 0) {
                isAllLand = false;
            }
        }
    }
    //全都是陆地或海洋
    if (isAllLand || isAllOcean) {
        return -1;
    }
    int dis = 0;
    int res = 0;
    while (!queue.isEmpty()) {
        int sz = queue.size();
        for (int i = 0; i < sz; i++) {
            int[] position = queue.poll();
            int x = position[0];
            int y = position[1];
            res = grid[x][y];
            for (int j = 0; j < 4; j++) {
                int newX = x + positionX[j];
                int newY = y + positionY[j];
                if (newX < 0 || newX >= grid.length || newY < 0 || newY >= grid[0].length || grid[newX][newY] != 0) {
                    continue;
                }
                //当前一层的值更改为上一层的值 + 1
                grid[newX][newY] = dis + 1;
                queue.offer(new int[]{newX, newY});
            }
        }
        dis++;
    }
    return res;
}
```

##### [1161. 最大层内元素和](https://leetcode.cn/problems/maximum-level-sum-of-a-binary-tree/)

```java
/**
     * BFS 层序遍历
     */
public int maxLevelSum(TreeNode root) {
    LinkedList<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int index = 1;
    int res = 0;
    int sum = Integer.MIN_VALUE;
    while (!queue.isEmpty()) {
        int sz = queue.size();
        int temp = 0;
        for (int i = 0; i < sz; i++) {
            TreeNode cur = queue.poll();
            temp += cur.val;
            if (cur.left != null) {
                queue.offer(cur.left);
            }
            if (cur.right != null) {
                queue.offer(cur.right);
            }
        }
        if (temp > sum) {
            sum = temp;
            res = index;
        }
        index++;
    }
    return res;
}
```

##### [1129. 颜色交替的最短路径](https://leetcode.cn/problems/shortest-path-with-alternating-colors/)

```java
public int[] shortestAlternatingPaths(int n, int[][] redEdges, int[][] blueEdges) {
    //构建邻接链表，保存红色和蓝色结点的图
    List<List<Integer>> redGraph = new LinkedList<>();
    List<List<Integer>> blueGraph = new LinkedList<>();
    for (int i = 0; i < n; i++) {
        redGraph.add(new LinkedList<>());
        blueGraph.add(new LinkedList<>());
    }
    for (int[] redEdge : redEdges) {
        int from = redEdge[0];
        int to = redEdge[1];
        redGraph.get(from).add(to);
    }
    for (int[] blueEdge : blueEdges) {
        int from = blueEdge[0];
        int to = blueEdge[1];
        blueGraph.get(from).add(to);
    }
    //防止蓝色和红色结点重复访问
    boolean[] redVisited = new boolean[n];
    boolean[] blueVisited = new boolean[n];
    LinkedList<int[]> queue = new LinkedList<>();
    redVisited[0] = true;
    blueVisited[0] = true;
    //从 0 出发，可以走红色和蓝色两条路，0 代表红色，1 代表蓝色
    //{0，0，0} 代表从 0 开始走，当前颜色是 0，当前走了 0 步
    queue.offer(new int[]{0, 0, 0});
    queue.offer(new int[]{0, 1, 0});
    int[] ans = new int[n];
    Arrays.fill(ans, -1);
    while (!queue.isEmpty()) {
        int[] position = queue.poll();
        int pos = position[0];
        int color = position[1];
        int len = position[2];
        if (ans[pos] == -1) {
            ans[pos] = len;
        }
        //已经走过红色了，应该选择走蓝色
        if (color == 0) {
            //寻找下一个可以去往的蓝色结点
            for (int next : blueGraph.get(pos)) {
                if (!blueVisited[next]) {
                    blueVisited[next] = true;
                    queue.offer(new int[]{next,1,len + 1});
                }
            }
        }
        //已经走过蓝色了，应该选择走红色
        if (color == 1) {
            //寻找下一个可以去往的红色结点
            for (int next : redGraph.get(pos)) {
                if (!redVisited[next]) {
                    redVisited[next] = true;
                    queue.offer(new int[]{next,0,len + 1});
                }
            }
        }

    }
    return ans;
}
```

##### [1254. 统计封闭岛屿的数目](https://leetcode.cn/problems/number-of-closed-islands/)

```java

/**
     * 多源 BFS，将边界陆地的结点加入队列，bfs 后只剩余内部的陆地，不与边界相连
     * 再次 BFS 并计算次数，就是封闭岛屿的数目
     */
int[] positionX = new int[]{1, -1, 0, 0};
int[] positionY = new int[]{0, 0, 1, -1};

public int closedIsland(int[][] grid) {
    int m = grid.length;
    int n = grid[0].length;
    LinkedList<int[]> queue = new LinkedList<>();
    for (int i = 0; i < m; i++) {
        if (grid[i][0] == 0) {
            grid[i][0] = 1;
            queue.offer(new int[]{i, 0});
        }
        if (grid[i][n - 1] == 0) {
            grid[i][n - 1] = 1;
            queue.offer(new int[]{i, n - 1});
        }
    }
    for (int i = 1; i < n - 1; i++) {
        if (grid[0][i] == 0) {
            grid[0][i] = 1;
            queue.offer(new int[]{0, i});
        }
        if (grid[m - 1][i] == 0) {
            grid[m - 1][i] = 1;
            queue.offer(new int[]{m - 1, i});
        }
    }
    bfs(grid, queue);
    int res = 0;
    //计算从陆地改为海洋所需要的次数
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == 0) {
                LinkedList<int[]> list = new LinkedList<>();
                list.offer(new int[]{i, j});
                grid[i][j] = 1;
                bfs(grid, list);
                res++;
            }
        }
    }
    return res;
}

public void bfs(int[][] grid, LinkedList<int[]> queue) {
    //遍历所有陆地，将陆地改为海洋
    while (!queue.isEmpty()) {
        int[] position = queue.poll();
        int x = position[0];
        int y = position[1];
        for (int i = 0; i < 4; i++) {
            int newX = x + positionX[i];
            int newY = y + positionY[i];
            if (newX < 0 || newX >= grid.length || newY < 0 || newY >= grid[0].length || grid[newX][newY] != 0) {
                continue;
            }
            grid[newX][newY] = 1;
            queue.offer(new int[]{newX, newY});
        }
    }
}
```

##### [1261. 在受污染的二叉树中查找元素](https://leetcode.cn/problems/find-elements-in-a-contaminated-binary-tree/)

```java
/**
* 给二叉树编号
*/
class FindElements {
    HashSet<Integer> value;

    public FindElements(TreeNode root) {
        value = new HashSet<>();
        root.val = 0;
        value.add(0);
        LinkedList<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            int sz = queue.size();
            for (int i = 0; i < sz; i++) {
                TreeNode cur = queue.poll();
                if (cur.left != null) {
                    cur.left.val = cur.val * 2 + 1;
                    value.add(cur.val * 2 + 1);
                    queue.offer(cur.left);
                }
                if (cur.right != null) {
                    cur.right.val = cur.val * 2 + 2;
                    value.add(cur.val * 2 + 2);
                    queue.offer(cur.right);
                }
            }
        }
    }

    public boolean find(int target) {
        return value.contains(target);
    }
}
```

##### [1302. 层数最深叶子节点的和](https://leetcode.cn/problems/deepest-leaves-sum/)

```java
public int deepestLeavesSum(TreeNode root) {
    LinkedList<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int sum = 0;
    while (!queue.isEmpty()) {
        sum = 0;
        int sz = queue.size();
        for (int i = 0; i < sz; i++) {
            TreeNode cur = queue.poll();
            sum += cur.val;
            if (cur.left != null) {
                queue.offer(cur.left);
            }
            if (cur.right != null) {
                queue.offer(cur.right);
            }
        }
    }
    return sum;
}
```

##### [1311. 获取你好友已观看的视频](https://leetcode.cn/problems/get-watched-videos-by-your-friends/)

```java
/**
     * BFS + 哈希表
     */
public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {
    int n = friends.length;
    //避免 bfs 重复访问
    boolean[] isVisited = new boolean[n];
    isVisited[id] = true;
    //存放到指定层级的朋友
    List<Integer> levelFriends = new ArrayList<>();
    LinkedList<Integer> queue = new LinkedList<>();
    //存放电影及其观看次数
    HashMap<String, Integer> dic = new HashMap<>();
    queue.offer(id);
    int index = 0;
    while (!queue.isEmpty()) {
        int sz = queue.size();
        for (int i = 0; i < sz; i++) {
            int cur = queue.poll();
            //到第 level 层朋友，加入指定的数组存储
            if (index == level) {
                levelFriends.add(cur);
            }
            int[] friend = friends[cur];
            //没访问过的朋友都加入队列，继续 bfs
            for (int fri : friend) {
                if (isVisited[fri]) {
                    continue;
                }
                isVisited[fri] = true;
                queue.offer(fri);
            }
        }
        index++;
    }
    //第 level 层朋友观看的电影及其次数
    for (int human : levelFriends) {
        List<String> strings = watchedVideos.get(human);
        for (String str : strings) {
            dic.put(str, dic.getOrDefault(str, 0) + 1);
        }
    }
    //map 自定义排序，先按 value 升序，再按 key 升序
    List<Map.Entry<String, Integer>> temp = new ArrayList<>(dic.entrySet());
    temp.sort((entry1, entry2) -> {
        if (entry1.getValue() == entry2.getValue()) {
            return entry1.getKey().compareTo(entry2.getKey());
        }
        return entry1.getValue() - entry2.getValue();
    });
    List<String> res = new ArrayList<>();
    for (Map.Entry<String, Integer> entry : temp) {
        res.add(entry.getKey());
    }
    return res;
}
```

##### [1361. 验证二叉树](https://leetcode.cn/problems/validate-binary-tree-nodes/)

```java
/**
     * BFS：记录所有结点的入度，找到第一个入度为 0 的结点，开始层序遍历。
     * 如果遍历过程中出现重复或者最后有节点没有访问到，则一定不是一棵有效的树
     */
public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {
    //记录每个结点的入度
    int[] inDegree = new int[n];
    for (int i = 0; i < n; i++) {
        if (leftChild[i] != -1) {
            inDegree[leftChild[i]]++;
        }
        if (rightChild[i] != -1) {
            inDegree[rightChild[i]]++;

        }
    }
    int root = -1;
    //找到一个入度为 0 的结点
    for (int i = 0; i < n; i++) {
        if (inDegree[i] == 0) {
            root = i;
            break;
        }
    }
    //没有找到入度为 0 的根节点，直接返回 false
    if (root == -1) {
        return false;
    }
    //存放访问过的结点
    HashSet<Integer> isVisited = new HashSet<>();
    LinkedList<Integer> queue = new LinkedList<>();
    queue.offer(root);
    isVisited.add(root);
    while (!queue.isEmpty()) {
        Integer cur = queue.poll();
        int left = leftChild[cur];
        if (left != -1) {
            if (isVisited.contains(left)) {
                return false;
            }
            isVisited.add(left);
            queue.offer(left);
        }
        int right = rightChild[cur];
        if (right != -1) {
            if (isVisited.contains(right)) {
                return false;
            }
            queue.offer(right);
            isVisited.add(right);
        }

    }
    //如果有结点未被访问，说明连通分量大于 1，不符合条件
    return isVisited.size() == n;
}
```

##### [1466. 重新规划路线](https://leetcode.cn/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/)

```java
class Vertex {
    int degree;
    int pos;

    public Vertex(int degree, int pos) {
        this.degree = degree;
        this.pos = pos;
    }
}

/**
     * BFS
     */
public int minReorder(int n, int[][] connections) {
    List<List<Vertex>> graph = new ArrayList<>();
    //构建邻接链表，记录每个结点的出度结点和入度结点
    for (int i = 0; i < n; i++) {
        graph.add(new ArrayList<>());
    }
    for (int[] arr : connections) {
        int from = arr[0];
        int to = arr[1];
        //入度为 1
        graph.get(from).add(new Vertex(1, to));
        //入度为 -1 ，说明出度为 1
        graph.get(to).add(new Vertex(-1, from));
    }
    LinkedList<Integer> queue = new LinkedList<>();
    queue.offer(0);
    int res = 0;
    boolean[] isVisited = new boolean[n];
    isVisited[0] = true;
    while (!queue.isEmpty()) {
        int cur = queue.poll();
        List<Vertex> vertices = graph.get(cur);
        for (Vertex vertex : vertices) {
            if (isVisited[vertex.pos]) {
                continue;
            }
            //如果一个结点的相邻结点的入度为 1
            if (vertex.degree == 1) {
                res++;
            }
            isVisited[vertex.pos] = true;
            queue.offer(vertex.pos);
        }
    }
    return res;
}
```

##### [1609. 奇偶树](https://leetcode.cn/problems/even-odd-tree/)

```java
/**
     * BFS：层序遍历，按照规则做好判断即可
     */
public boolean isEvenOddTree(TreeNode root) {
    LinkedList<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int index = 0;
    while (!queue.isEmpty()) {
        int size = queue.size();
        int pre = 0;
        for (int i = 0; i < size; i++) {
            TreeNode cur = queue.poll();
            if (index % 2 == 0) {
                if (cur.val % 2 == 0) {
                    return false;
                }
                if (cur.val <= pre) {
                    return false;
                }
            } else {
                if (cur.val % 2 == 1) {
                    return false;
                }
                if (pre != 0 && cur.val >= pre) {
                    return false;
                }
            }
            pre = cur.val;
            if (cur.left != null) {
                queue.offer(cur.left);
            }
            if (cur.right != null) {
                queue.offer(cur.right);
            }
        }
        index++;
    }
    return true;
}
```

##### [1765. 地图中的最高点](https://leetcode.cn/problems/map-of-highest-peak/)

```java
/**
     * 多源 BFS
     */
int[] positionX = new int[]{1, -1, 0, 0};
int[] positionY = new int[]{0, 0, -1, 1};

public int[][] highestPeak(int[][] isWater) {
    LinkedList<int[]> queue = new LinkedList<>();
    int m = isWater.length;
    int n = isWater[0].length;
    int[][] res = new int[m][n];
    for (int i = 0; i < m; i++) {
        Arrays.fill(res[i], -1);
    }
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (isWater[i][j] == 1) {
                res[i][j] = 0;
                queue.offer(new int[]{i, j});
            }
        }
    }

    int index = 1;
    while (!queue.isEmpty()) {
        int sz = queue.size();
        for (int i = 0; i < sz; i++) {
            int[] position = queue.poll();
            int x = position[0];
            int y = position[1];
            for (int j = 0; j < 4; j++) {
                int newX = x + positionX[j];
                int newY = y + positionY[j];
                if (newX < 0 || newX >= m || newY < 0 || newY >= n || res[newX][newY] != -1) {
                    continue;
                }
                res[newX][newY] = index;
                queue.offer(new int[]{newX, newY});
            }
        }
        index++;
    }
    return res;
}
```

##### [1654. 到家的最少跳跃次数](https://leetcode.cn/problems/minimum-jumps-to-reach-home/)

```java
/**
     * BFS 求最值，最远只能到 x + a +b，再远就没意义了,x,a,b <= 2000
     */
public int minimumJumps(int[] forbidden, int a, int b, int x) {
    final int LIMIT = 6000;
    //一步到家
    if (x == a) {
        return 1;
    }
    boolean[][] visited = new boolean[8001][2];
    Set<Integer> forbid = new HashSet<>(forbidden.length);
    for (int i : forbidden) {
        if (i == x) {
            return -1;
        }
        forbid.add(i);
    }
    LinkedList<int[]> queue = new LinkedList<>();
    //0，0 代表当前所在位置 0 和当前已经连续后退的次数 0
    queue.offer(new int[]{0, 0});
    int layer = 0;
    while (!queue.isEmpty()) {
        int qs = queue.size();
        for (int i = 0; i < qs; i++) {
            int[] p = queue.poll();
            int cur = p[0], backwardCount = p[1];
            if (cur == x) return layer;
            if (visited[cur][backwardCount]) continue;
            visited[cur][backwardCount] = true;

            if (cur + a <= LIMIT && !forbid.contains(cur + a)) {
                queue.offer(new int[]{cur + a, 0});
            }
            if (cur - b >= 0 && backwardCount < 1 && !forbid.contains(cur - b)) {
                queue.offer(new int[]{cur - b, backwardCount + 1});
            }
        }
        layer++;
    }
    return -1;
}
```

##### [1926. 迷宫中离入口最近的出口](https://leetcode.cn/problems/nearest-exit-from-entrance-in-maze/)

```java
/**
     * BFS 求最值
     */
int[] positionX = new int[]{-1, 1, 0, 0};
int[] positionY = new int[]{0, 0, -1, 1};

public int nearestExit(char[][] maze, int[] entrance) {
    int m = maze.length;
    int n = maze[0].length;
    LinkedList<int[]> queue = new LinkedList<>();
    int startX = entrance[0];
    int startY = entrance[1];
    queue.offer(new int[]{startX, startY});
    maze[startX][startY] = '+';
    int step = 1;
    while (!queue.isEmpty()) {
        int sz = queue.size();
        for (int i = 0; i < sz; i++) {
            int[] position = queue.poll();
            int x = position[0];
            int y = position[1];
            for (int j = 0; j < 4; j++) {
                int newX = x + positionX[j];
                int newY = y + positionY[j];
                if (newX < 0 || newX >= m || newY < 0 || newY >= n || maze[newX][newY] == '+') {
                    continue;
                }
                //碰到出口，立刻返回
                if (newX == m - 1 || newY == n - 1 || newX == 0 || newY == 0) {
                    return step;
                }
                maze[newX][newY] = '+';
                queue.offer(new int[]{newX, newY});
            }
        }
        step++;
    }
    return -1;
}
```

##### [1992. 找到所有的农场组](https://leetcode.cn/problems/find-all-groups-of-farmland/)

```java
//走四方
int[] positionX = new int[]{-1, 1, 0, 0};
int[] positionY = new int[]{0, 0, -1, 1};
List<int[]> res = new ArrayList<>();
public int[][] findFarmland(int[][] land) {
    int m = land.length;
    int n = land[0].length;
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            //每个农场组的左上角一定是最先被加入队列的
            if (land[i][j] == 1) {
                bfs(land, i, j);
            }
        }
    }
    return res.toArray(new int[0][0]);
}

public void bfs(int[][] land, int x, int y) {
    LinkedList<int[]> queue = new LinkedList<>();
    queue.offer(new int[]{x, y});
    //设置为 0 表示已访问过
    land[x][y] = 0;
    int[] temp = new int[4];
    temp[0] = x;
    temp[1] = y;
    int lastX = 0;
    int lastY = 0;
    while (!queue.isEmpty()) {
        int[] position = queue.poll();
        lastX = position[0];
        lastY = position[1];
        for (int i = 0; i < 4; i++) {
            int newX = position[0] + positionX[i];
            int newY = position[1] + positionY[i];
            if (newX < 0 || newX >= land.length || newY < 0 || newY >= land[0].length || land[newX][newY] != 1) {
                continue;
            }
            queue.offer(new int[]{newX, newY});
            land[newX][newY] = 0;
        }
    }
    temp[2] = lastX;
    temp[3] = lastY;
    res.add(temp);
}
```







#### DFS

[463. 岛屿的周长](https://leetcode.cn/problems/island-perimeter/)

```java
/**
     * DFS：从第一个陆地开始 dfs，访问过的陆地值改为 2。由陆地向四方搜索，如果四方是水域或超出边界，则周长+1
     */
private int res = 0;
public int islandPerimeter(int[][] grid) {
    int m = grid.length;
    int n = grid[0].length;
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == 1) {
                dfs(grid, i, j);
            }
        }
    }
    return res;
}

private void dfs(int[][] grid, int x, int y) {
    //超过边界
    if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[x][y] == 0) {
        res++;
        return;
    }
    //该点已经访问过了
    if (grid[x][y] == 2) {
        return;
    }
    //该点标记为访问过
    grid[x][y] = 2;
    //向四个方向走动，看是否为水域，如果为水域或超出边界，则++
    dfs(grid, x - 1, y);
    dfs(grid, x + 1, y);
    dfs(grid, x, y - 1);
    dfs(grid, x, y + 1);
}
```

##### [733. 图像渲染](https://leetcode.cn/problems/flood-fill/)

##### [面试题 08.10. 颜色填充](https://leetcode.cn/problems/color-fill-lcci/)

```java
int[] direactionX = new int[]{-1, 1, 0, 0};
int[] direactionY = new int[]{0, 0, 1, -1};
public int[][] floodFill(int[][] image, int sr, int sc, int color) {
    if (image[sr][sc] == color) {
        return image;
    }
    dfs(image, sr, sc, image[sr][sc], color);
    return image;
}

private void dfs(int[][] grid, int x, int y, int srcColor, int color) {
    if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[x][y] != srcColor) {
        return;
    }
    grid[x][y] = color;
    for (int i = 0; i < 4; i++) {
        dfs(grid, x + direactionX[i], y + direactionY[i], srcColor, color);
    }
}
```

##### [LCP 07. 传递信息](https://leetcode.cn/problems/chuan-di-xin-xi/)

```java
/**
     * DFS: 邻接矩阵存储图，List<List<Integer>> 中外层中 list 代表顶点，内层 list 代表一个顶点的所有出边指向的另一个顶点
     */
private int res;
public int numWays(int n, int[][] relation, int k) {
    List<List<Integer>> edges = new ArrayList<>();
    for (int i = 0; i < n; i++) {
        edges.add(new ArrayList<>());
    }
    for (int[] arr : relation) {
        int index = arr[0];
        int value = arr[1];
        edges.get(index).add(value);
    }
    //从编号为 0 的顶点开始，走到编号为 n - 1 的顶点，只走 k 步就能到达的方案树数
    dfs(edges, 0, 0, k);
    return res;
}

private void dfs(List<List<Integer>> edges, int index, int step, int k) {
    //已经走了 k 步了
    if (step == k) {
        //且已经到达 n -1 的顶点
        if (index == edges.size() - 1) {
            res++;
        }
        return;
    }
    //获取当前节点的所有出边顶点
    List<Integer> temp = edges.get(index);
    //找到出边顶点的位置
    for (Integer nextIndex : temp) {
        //继续 dfs
        dfs(edges, nextIndex, step + 1, k);
    }
}
```

##### [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)

```java
/**
   * BFS：找到一个陆地后将岛屿修改为 0，避免重复访问，根据 BFS 次数返回结果
   */
int[] positionX = new int[]{-1, 1, 0, 0};
int[] positionY = new int[]{0, 0, -1, 1};

public int numIslands(char[][] grid) {
    int m = grid.length;
    int n = grid[0].length;
    int res = 0;
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == '1') {
                dfs(grid, i, j);
                res++;
            }
        }
    }
    return res;
}

private void dfs(char[][] grid, int x, int y) {
    if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[x][y] != '1') {
        return;
    }
    grid[x][y] = 0;
    for (int i = 0; i < 4; i++) {
        int newX = x + positionX[i];
        int newY = y + positionY[i];
        dfs(grid, newX, newY);
    }
}
```

##### [207. 课程表](https://leetcode.cn/problems/course-schedule/)

```java
/**
   * 检测有向图是否有环，所有结点都调一遍 dfs
   */
//记录该结点是否已经走过，走过可以跳过
boolean[] isVisited;
//记录每个结点走过的路径，若在一次dfs调用中，路径重复走，说明有环
boolean[] onPath;
boolean hasCycle;
//邻接表存储图
List<List<Integer>> graph = new ArrayList<>();
public boolean canFinish(int numCourses, int[][] prerequisites) {
    isVisited = new boolean[numCourses];
    onPath = new boolean[numCourses];
    for (int i = 0; i < numCourses; i++) {
        graph.add(new ArrayList<>());
    }
    int m = prerequisites.length;
    for (int i = 0; i < m; i++) {
        int from = prerequisites[i][1];
        int to = prerequisites[i][0];
        graph.get(from).add(to);
    }
    //不能确保有环，所有结点都得调用一遍
    for (int i = 0; i < numCourses; i++) {
        dfs(i);
    }
    return !hasCycle;
}

private void dfs(int index) {
    //一次调用中路径重复走，有环
    if (onPath[index]) {
        hasCycle = true;
        return;
    }
    //已经访问过的结点无需再访问
    if (isVisited[index]) {
        return;
    }
    //isVisited 是对所有结点是否访问过的全局记录，不需要回溯
    isVisited[index] = true;
    //onPath 是一次调用中一个结点可以走的所有路径的局部记录，需要回溯
    onPath[index] = true;
    List<Integer> list = graph.get(index);
    for (int i = 0; i < list.size(); i++) {
        dfs(list.get(i));
    }
    onPath[index] = false;
}
```

##### [133. 克隆图](https://leetcode.cn/problems/clone-graph/)

```java
//判断图结点是否走过  
HashSet<Node> set = new HashSet<>();
//存储旧结点和新节点的映射
HashMap<Node, Node> dic = new HashMap<>();
public Node cloneGraph(Node node) {
    dfs(node);
    return dic.get(node);
}

private void dfs(Node node) {
    if (node == null) {
        return;
    }
    if (set.contains(node)) {
        return;
    }
    if (!dic.containsKey(node)) {
        dic.put(node, new Node(node.val));
        set.add(node);
    }
    Node newNode = dic.get(node);
    List<Node> neighbors = node.neighbors;
    for (Node n : neighbors) {
        //dfs 之后，n 结点已被复制了一份
        dfs(n);
        Node temp = dic.get(n);
        newNode.neighbors.add(temp);
    }
}
```

##### [417. 太平洋大西洋水流问题](https://leetcode.cn/problems/pacific-atlantic-water-flow/)

```java
/**
     * DFS：从上边和左边 dfs 获取可以流入太平洋的点，从下边和右边 dfs 获取可以流入大西洋的点，两者取交集
     */
int[] positionX = new int[]{-1, 1, 0, 0};
int[] positionY = new int[]{0, 0, 1, -1};
int[][] heights;

public List<List<Integer>> pacificAtlantic(int[][] heights) {
    this.heights = heights;
    int m = heights.length;
    int n = heights[0].length;
    boolean[][] pac = new boolean[m][n];
    boolean[][] ath = new boolean[m][n];
    //上方
    for (int i = 1; i < n; i++) {
        dfs(0, i, pac);
    }
    //下边
    for (int i = 0; i < n - 1; i++) {
        dfs(m - 1, i, ath);
    }
    //左边
    for (int i = 0; i < m; i++) {
        dfs(i, 0, pac);
    }
    //右边
    for (int i = 0; i < m; i++) {
        dfs(i, n - 1, ath);
    }
    List<List<Integer>> res = new LinkedList<>();
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (pac[i][j] && ath[i][j]) {
                ArrayList<Integer> temp = new ArrayList<>();
                temp.add(i);
                temp.add(j);
                res.add(temp);
            }
        }
    }
    return res;
}

private void dfs(int x, int y, boolean[][] ocean) {
    if (ocean[x][y]) {
        return;
    }
    ocean[x][y] = true;
    for (int i = 0; i < 4; i++) {
        int newX = x + positionX[i];
        int newY = y + positionY[i];
        if (newX < 0 || newX >= ocean.length || newY < 0 || newY >= ocean[0].length || heights[newX][newY] < heights[x][y]) {
            continue;
        }
        dfs(newX, newY, ocean);
    }
}
```

##### [529. 扫雷游戏](https://leetcode.cn/problems/minesweeper/)

```java
/**
     * BFS：向四个方向以及四个对角遍历
     * 扫雷规则：
     * 1. 如果点击到炸弹，直接返回
     * 2. 如果点击到空白块，需要遍历以空白块为中心的九宫格，
     *         若没有雷，继续 bfs 空白块，将所有空白块打开
     *         若有雷，当前空白块改为雷的个数，无需在 bfs
     */
int[] positionX = {1, -1, 0, 0, 1, 1, -1, -1};
int[] positionY = {0, 0, 1, -1, 1, -1, 1, -1};
public char[][] updateBoard(char[][] board, int[] click) {
    int m = board.length;
    int n = board[0].length;
    int x = click[0];
    int y = click[1];
    char ch = board[x][y];
    if (ch == 'M') {
        board[x][y] = 'X';
        return board;
    }
    if (ch == 'E') {
        dfs(board, x, y);
    }
    return board;
}

public void dfs(char[][] board, int x, int y) {
    //扫到一个不是雷的区块，需要遍历九宫格，查看九宫格内雷的个数
    int count = 0;
    for (int i = 0; i < 8; i++) {
        int newX = positionX[i] + x;
        int newY = positionY[i] + y;
        if (newX < 0 || newX >= board.length || y < 0 || y >= board[0].length || board[newX][newY] != 'M') {
            continue;
        }
        count++;
    }
    //有雷，修改为雷的个数，无需在 bfs
    if (count > 0) {
        board[x][y] = (char) (count + 'a');
    } else {
        //无雷，继续 bfs 直到有雷为止
        board[x][y] = 'B';
        for (int i = 0; i < 8; i++) {
            int newX = positionX[i] + x;
            int newY = positionY[i] + y;
            if (newX < 0 || newX >= board.length || y < 0 || y >= board[0].length || board[newX][newY] != 'E') {
                continue;
            }
            dfs(board, newX, newY);
        }
    }
}
```

##### [542. 01 矩阵](https://leetcode.cn/problems/01-matrix/)

```java
/**
     * BFS
     * 将所有 0 加入队列后，将 0 周围的一圈节点都变为 1 并入队。
     * 将所有 1 出队，将 1 周围的一圈节点变为 2 并入队...
     */
int[] positionX = {1, -1, 0, 0};
int[] positionY = {0, 0, 1, -1};

public int[][] updateMatrix(int[][] mat) {
    int m = mat.length;
    int n = mat[0].length;
    LinkedList<int[]> queue = new LinkedList<>();
    boolean[][] isVisited = new boolean[m][n];
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (mat[i][j] == 0) {
                //将所有 0 加入队列
                queue.add(new int[]{i, j});
                isVisited[i][j] = true;
            }
        }
    }
    while (!queue.isEmpty()) {
        int[] position = queue.poll();
        int x = position[0];
        int y = position[1];
        for (int i = 0; i < 4; i++) {
            int newX = x + positionX[i];
            int newY = y + positionY[i];
            if (newX < 0 || newX >= mat.length || newY < 0 || newY >= mat[0].length || isVisited[newX][newY]) {
                continue;
            }
            mat[newX][newY] = mat[x][y] + 1;
            queue.offer(new int[]{newX, newY});
            isVisited[newX][newY] = true;
        }
    }
    return mat;
}
```

##### [756. 金字塔转换矩阵](https://leetcode.cn/problems/pyramid-transition-matrix/)

```java
/**
     * DFS: dfs的参数是下一层和当前层，最底层bottom给定，第二层初始为""
     * 当下一层只有一个字符时，说明到达顶端，返回true
     * 当前层比下一层长度小1，说明当前层已经完成，dfs到上一层
     */
Map<String, List<Character>> two2all;
public boolean pyramidTransition(String bottom, List<String> allowed) {
    two2all = new HashMap<>();
    for (String str : allowed) {
        String subStr = str.substring(0, 2);
        char ch = str.charAt(2);
        List<Character> list = two2all.getOrDefault(subStr, new ArrayList<>());
        list.add(ch);
        two2all.put(subStr, list);
    }
    return dfs(bottom, "");
}

public boolean dfs(String pre, String cur) {
    if (pre.length() == 1) {
        return true;
    }
    if (cur.length() + 1 == pre.length()) {
        return dfs(cur, "");
    }
    String subStr = pre.substring(cur.length(), cur.length() + 2);
    if (two2all.containsKey(subStr)) {
        for (char x : two2all.get(subStr)) {
            //有一种情况成功就返回
            if (dfs(pre, cur + x)) {
                return true;
            }
        }
    }
    return false;
}
```

##### [802. 找到最终的安全状态](https://leetcode.cn/problems/find-eventual-safe-states/)

```java
/**
     * BFS + 三色标记，如果有环，该节点不安全，直接返回
     * 0 为节点未被访问
     * 1 为节点处于一个环中或被访问过
     * 2 为节点是个安全节点
     */
public List<Integer> eventualSafeNodes(int[][] graph) {
    int n = graph.length;
    int[] color = new int[n];
    List<Integer> res = new ArrayList<>();
    for (int i = 0; i < n; i++) {
        //需要遍历所有节点
        if(dfs(graph, color, i)){
            res.add(i);
        }
    }
    return res;
}

private boolean dfs(int[][] graph, int[] color, int index) {
    //只要成环，直接返回 false
    if (color[index] > 0) {
        return color[index] == 2;
    }
    //将节点标为已访问
    color[index] = 1;
    for (int next : graph[index]) {
        //只要成环就失败
        if (!dfs(graph, color, next)) {
            return false;
        }
    }
    //dfs该节点，没有发现成环，该节点改为安全状态
    color[index] = 2;
    return true;
}
```

##### [841. 钥匙和房间](https://leetcode.cn/problems/keys-and-rooms/)

```java
public boolean canVisitAllRooms(List<List<Integer>> rooms) {
    LinkedList<Integer> queue = new LinkedList<>();
    //标记房间是否访问过
    boolean[] isVisited = new boolean[rooms.size()];
    //从第一个房间开始
    isVisited[0] = true;
    //将第一个房间内的钥匙加入队列
    for (Integer num : rooms.get(0)) {
        queue.offer(num);
        isVisited[num] = true;
    }
    while (!queue.isEmpty()) {
        Integer curRoom = queue.poll();
        List<Integer> list = rooms.get(curRoom);
        for (Integer num : list) {
            if (isVisited[num]) {
                continue;
            }
            isVisited[num] = true;
            queue.offer(num);
        }
    }
    //最终必须所有房间都访问过
    for (boolean valid : isVisited) {
        if (!valid) {
            return false;
        }
    }
    return true;
}
```

##### [967. 连续差相同的数字](https://leetcode.cn/problems/numbers-with-same-consecutive-differences/)

```java
/**
   * DFS：第一位加入 1-9，后续 dfs 根据前一位选出合适的数字，直到数字拼凑完毕
   */
private ArrayList<Integer> list;
public int[] numsSameConsecDiff(int n, int k) {
    list = new ArrayList<>();
    //首位数字
    for (int i = 1; i <= 9; i++) {
        if (i + k > '9' && i - k < '0') {
            continue;
        }
        StringBuilder builder = new StringBuilder();
        builder.append(i);
        dfs(n, 1, k, builder);
    }
    int[] res = new int[list.size()];
    for (int i = 0; i < list.size(); i++) {
        res[i] = list.get(i);
    }
    return res;
}

public void dfs(int n, int count, int k, StringBuilder builder) {
    if (count == n) {
        list.add(Integer.parseInt(builder.toString()));
        return;
    }
    //获取前一位数字
    char c = builder.charAt(count - 1);
    // k = 0 的时候也可以通过
    if (c + k <= '9') {
        builder.append((char) (c + k));
        dfs(n, count + 1, k, builder);
        builder.setLength(builder.length() - 1);
    }
    //k = 0 时已经计算过一次，不需要重复计算
    if (c - k >= '0' && k  != 0) {
        builder.append((char) (c - k));
        dfs(n, count + 1, k, builder);
        builder.setLength(builder.length() - 1);
    }
}
```

##### [1034. 边界着色](https://leetcode.cn/problems/coloring-a-border/)

```java
/**
     * DFS: dfs 中判定
     */
int[] positionX = new int[]{-1, 1, 0, 0};
int[] positionY = new int[]{0, 0, -1, 1};

public int[][] colorBorder(int[][] grid, int row, int col, int color) {
    int m = grid.length;
    int n = grid[0].length;
    //记录该涂色的结点
    List<int[]> borders = new ArrayList<>();
    //记录原本颜色
    int oldColor = grid[row][col];
    boolean[][] isVisited = new boolean[m][n];
    isVisited[row][col] = true;
    dfs(grid, row, col, borders, isVisited);
    //涂色
    for (int[] arr : borders) {
        grid[arr[0]][arr[1]] = color;
    }
    return grid;
}

public void dfs(int[][] grid, int x, int y, List<int[]> borders, boolean[][] isVisited) {
    boolean isBorder = false;
    for (int i = 0; i < 4; i++) {
        int newX = x + positionX[i];
        int newY = y + positionY[i];
        //只要该结点的四周结点越界（说明该结点为边界）或者和值不相同的结点相邻（处于两种颜色的交界），该结点就应该被涂色
        if (!(newX >= 0 && newX < grid.length && newY >= 0 && newY < grid[0].length && grid[newX][newY] == grid[x][y])) {
            isBorder = true;
            //将四周结点加入 dfs
        } else if (!isVisited[newX][newY]) {
            isVisited[newX][newY] = true;
            dfs(grid, newX, newY, borders, isVisited);
        }
    }
    //确认该结点是边界，加入集合
    if (isBorder) {
        borders.add(new int[]{x, y});
    }
}
```

##### [1306. 跳跃游戏 III](https://leetcode.cn/problems/jump-game-iii/)

```java
/**
     * DFS，从一个点可以往左或往右 继续 dfs
     */
boolean isValid = false;
public boolean canReach(int[] arr, int start) {
    int n = arr.length;
    boolean[] isVisited = new boolean[n];
    dfs(arr,start, isVisited);
    return isValid;
}

public void dfs(int[] arr, int start, boolean[] isVisited) {
    if (start < 0 || start >= arr.length || isVisited[start]) {
        return;
    }
    if (arr[start] == 0) {
        isValid = true;
        return;
    }
    isVisited[start] = true;
    int next = arr[start];
    dfs(arr, start + next, isVisited);
    dfs(arr, start - next, isVisited);
}

```

##### [1376. 通知所有员工所需的时间](https://leetcode.cn/problems/time-needed-to-inform-all-employees/)

```java
/**
     * DFS：多叉树从根结点到叶子结点最大路径和
     */
int res = 0;
public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {
    List<List<Integer>> graph = new ArrayList<>();
    for (int i = 0; i < n; i++) {
        graph.add(new ArrayList<>());
    }
    //保存父节点及其所有的子结点，叶子结点的集合为空
    for (int i = 0; i < n; i++) {
        if (manager[i] != -1) {
            graph.get(manager[i]).add(i);
        }
    }
    //从根节点开始遍历，寻找到叶子结点路径和的最大值
    dfs(graph, informTime, headID, informTime[headID]);
    return res;
}

private void dfs(List<List<Integer>> graph, int[] time, int index, int sum) {
    //到达叶子结点
    List<Integer> list = graph.get(index);
    if (list.isEmpty()) {
        res = Math.max(res, sum);
        return;
    }
    //继续往下 dfs
    for (int num : list) {
        dfs(graph, time, num, sum + time[num]);
    }
}
```

##### [1391. 检查网格中是否存在有效路径](https://leetcode.cn/problems/check-if-there-is-a-valid-path-in-a-grid/)

```java
boolean isValid = false;

public boolean hasValidPath(int[][] grid) {
    dfs(grid, 0, 0);
    return isValid;
}

public void dfs(int[][] grid, int x, int y) {
    int m = grid.length;
    int n = grid[0].length;
    //已找到一条到达右下角的路，返回
    if (isValid) {
        return;
    }
    //到达右下角立即返回
    if (x == m - 1 && y == n - 1) {
        isValid = true;
        return;
    }
    int type = grid[x][y];
    //修改访问过的地方，避免重复访问
    grid[x][y] = -1;
    //每种类型的
    switch (type) {
        case 1:
            //向左走
            dispatcher("left", grid, x, y);
            //向右走
            dispatcher("right", grid, x, y);
            break;
        case 2:
            //向上走
            dispatcher("up", grid, x, y);
            //向下走
            dispatcher("down", grid, x, y);
            break;
        case 3:
            //向左走
            dispatcher("left", grid, x, y);
            //向下走
            dispatcher("down", grid, x, y);
            break;
        case 4:
            //向下走
            dispatcher("down", grid, x, y);
            //向右走
            dispatcher("right", grid, x, y);
            break;
        case 5:
            //向左走
            dispatcher("left", grid, x, y);
            //向上走
            dispatcher("up", grid, x, y);
        case 6:
            //向上走
            dispatcher("up", grid, x, y);
            //向右走
            dispatcher("right", grid, x, y);
    }
}

public void dispatcher(String s, int[][] grid, int x, int y) {
    int m = grid.length;
    int n = grid[0].length;
    if (s.equals("left")) {
        //满足条件才能向左走
        if (y - 1 >= 0) {
            int next = grid[x][y - 1];
            if (next == 1 || next == 4 || next == 6) {
                dfs(grid, x, y - 1);
            }
        }
    } else if (s.equals("right")) {
        //向右走
        if (y + 1 < n) {
            int next = grid[x][y + 1];
            if (next == 1 || next == 3 || next == 5) {
                dfs(grid, x, y + 1);
            }
        }
    } else if (s.equals("up")) {
        //向上走
        if (x - 1 >= 0) {
            int next = grid[x - 1][y];
            if (next == 2 || next == 3 || next == 4) {
                dfs(grid, x - 1, y);
            }
        }
    } else if (s.equals("down")) {
        //向下走
        if (x + 1 < m) {
            int next = grid[x + 1][y];
            if (next == 2 || next == 5 || next == 6) {
                dfs(grid, x + 1, y);
            }
        }
    }
}
```

##### [1443. 收集树上所有苹果的最少时间](https://leetcode.cn/problems/minimum-time-to-collect-all-apples-in-a-tree/)

```java
//构建子结点和父结点之间的映射，可以通过子结点找到父结点
public void buildReverseEdges(List<List<Integer>> graph, int index) {
    for (int num : graph.get(index)) {
        if(num != 0 && reverseEdges[num] == -1) {
            reverseEdges[num] = index;
            buildReverseEdges(graph, num);
        }
    }
}

int ans = 0;
int[] reverseEdges;
boolean[] visited;

public int minTime(int n, int[][] edges, List<Boolean> hasApple) {
    List<List<Integer>> graph = new ArrayList<>(n);
    for (int i = 0; i < n; i++) {
        graph.add(new ArrayList<>());
    }
    //构建邻接链表
    for (int[] edge : edges) {
        graph.get(edge[0]).add(edge[1]);
        graph.get(edge[1]).add(edge[0]);
    }
    //构建反向映射，通过子结点查找父节点
    reverseEdges = new int[n];
    Arrays.fill(reverseEdges, -1);
    //确保能通过子结点(下标）找到父结点，父结点记录在reverseEdges数组中
    buildReverseEdges(graph, 0);
    visited = new boolean[n];
    //从根结点开始
    visited[0] = true;
    for (int i = 0; i < n; i++) {
        //找到苹果后，从苹果结点开始往根结点走
        if (hasApple.get(i)) {
            dfsEdge(i);
        }
    }
    //最终的路径是苹果到根结点的两倍
    return ans * 2;
}


public void dfsEdge(int to) {
    if (!visited[to]) {
        visited[to] = true;
        ans++;
        dfsEdge(reverseEdges[to]);
    }
}
```

##### [1625. 执行操作后字典序最小的字符串](https://leetcode.cn/problems/lexicographically-smallest-string-after-applying-operations/)

```java
/**
     * DFS，找到全局最小字符串
     */
String res;

public String findLexSmallestString(String s, int a, int b) {
    res = s;
    HashSet<String> isVisited = new HashSet<>();
    dfs(s, a, b, isVisited);
    return res;
}

public void dfs(String s, int a, int b, HashSet<String> isVisited) {
    if (isVisited.contains(s)) {
        return;
    }
    isVisited.add(s);
    if (res.compareTo(s) > 0) {
        res = s;
    }
    StringBuilder builder = new StringBuilder();
    //累加
    for (int i = 0; i < s.length(); i++) {
        char ch = s.charAt(i);
        if (i % 2 == 0) {
            builder.append(ch);
            continue;
        }
        int num = ((ch -'0') + a) % 10;
        builder.append(num);
    }
    dfs(builder.toString(), a, b, isVisited);
    //轮转
    String head = s.substring(s.length() - b, s.length());
    String tail = s.substring(0, s.length() - b);
    dfs(head + tail, a, b, isVisited);
}
```

##### [1905. 统计子岛屿](https://leetcode.cn/problems/count-sub-islands/)

```java
/**
     * DFS：寻找岛屿 1 的岛屿 2 中的子岛屿
     * 如果岛屿 1 为海水但是岛屿 2 为陆地，则岛屿 2 肯定不是岛屿 1 的子岛屿
     */
int[] positionX = new int[]{-1, 1, 0, 0};
int[] positionY = new int[]{0, 0, 1, -1};

public int countSubIslands(int[][] grid1, int[][] grid2) {
    int m = grid1.length;
    int n = grid1[0].length;
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            //肯定不是子岛屿，直接淹掉
            if (grid1[i][j] == 0 && grid2[i][j] == 1) {
                dfs(grid2, i, j);
            }
        }
    }
    int res = 0;
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid2[i][j] == 1) {
                dfs(grid2, i, j);
                res++;
            }
        }
    }
    return res;
}

//将一个岛屿淹掉
public void dfs(int[][] grid1, int x, int y) {
    grid1[x][y] = 0;
    for (int i = 0; i < 4; i++) {
        int newX = x + positionX[i];
        int newY = y + positionY[i];
        if (newX < 0 || newX >= grid1.length || newY < 0 || newY >= grid1[0].length || grid1[newX][newY] == 0) {
            continue;
        }
        dfs(grid1, newX, newY);
    }
}
```





#### 树-递归或迭代

##### [100. 相同的树](https://leetcode.cn/problems/same-tree/)

```java
/**
* 两棵树的左右结点相同且两棵数的结点值相同，或两棵树都为 null 才返回 true
*/
public boolean isSameTree(TreeNode p, TreeNode q) {
    if (p == null && q == null) {
        return true;
    }
    if (p == null || q == null) {
        return false;
    }
    if (p.val != q.val) {
        return false;
    }
    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
}
```

##### [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

```java
public boolean isSymmetric(TreeNode root) {
    if (root == null) {
        return true;
    }
    return traverse(root.left, root.right);
}

/**
   * 左右结点必须值相同，且左右结点也为对称的树
   */
public boolean traverse(TreeNode left, TreeNode right) {
    if (left == null && right == null) {
        return true;
    }
    if (left == null || right == null) {
        return false;
    }
    return left.val == right.val && traverse(left.left, right.right) && traverse(left.right, right.left);
}
```

##### [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

```java
private int res = 0;
public int maxDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    traverse(root, 0);
    return res;
}

public void traverse(TreeNode root, int index) {
    if (root == null) {
        res = Math.max(res, index);
        return;
    }
    traverse(root.left, index + 1);
    traverse(root.right, index + 1);
}
```

##### [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)<span id="to226"></span>

```java
public TreeNode invertTree(TreeNode root) {
    if (root == null) {
        return null;
    }
    return traverse(root);
}

private TreeNode traverse(TreeNode root) {
    if (root == null) {
        return null;
    }
    //左子树已经翻转完毕
    TreeNode left = traverse(root.left);
    //左子树已经翻转完毕
    TreeNode right = traverse(root.right);
    //左右节点交换
    root.right = left;
    root.left = right;
    return root;
}
```

##### [404. 左叶子之和](https://leetcode.cn/problems/sum-of-left-leaves/)

```java
private int res;
public int sumOfLeftLeaves(TreeNode root) {
    traverse(root);
    return res;
}

private void traverse(TreeNode root) {
    if (root == null) {
        return;
    }
    //当前节点的左节点
    if (root.left != null) {
        //当前节点的左节点是叶子节点
        if (root.left.left == null && root.left.right == null) {
            res += root.left.val;
        }
    }
    traverse(root.left);
    traverse(root.right);

}
```

##### [530. 二叉搜索树的最小绝对差](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)

```java
/**
     * 二叉搜索树的中序遍历为递增序列，中序遍历即可，遍历过程需要一个节点记录上一个节点
     */
private int res = Integer.MAX_VALUE;
private TreeNode pre;

public int getMinimumDifference(TreeNode root) {
    traverse(root);
    return res;
}

private void traverse(TreeNode cur) {
    if (cur == null) {
        return;
    }
    traverse(cur.left);
    if (pre != null) {
        res = Math.min(res, (cur.val - pre.val));
    }
    //更新下一个节点
    pre = cur;
    traverse(cur.right);
}
```

##### [559. N 叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/)

```java
private int res = 0;
public int maxDepth(Node root) {
    traverse(root, 1);
    return res;
}

private void traverse(Node root, int index) {
    if (root == null) {
        return;
    }
    //多叉树的叶子节点
    if (root.children.isEmpty()) {
        res = Math.max(res, index);
    }
    for (int i = 0; i < root.children.size(); i++) {
        traverse(root.children.get(i), index + 1);
    }
}
```

##### [617. 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/)

```java
/**
* 递归
*/
public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
    if (root1 == null ){
        return root2;
    }
    if (root2 == null) {
        return root1;
    }
    root1.val += root2.val;
    root1.left = mergeTrees(root1.left, root2.left);
    root1.right = mergeTrees(root1.right, root2.right);
    return root1;
}
```

##### [653. 两数之和 IV - 输入 BST](https://leetcode.cn/problems/two-sum-iv-input-is-a-bst/)

```java
/**
     * 二叉搜索树的中序遍历为递增序列，set 保存获取的值，每获取到一个节点值时去 set 寻找是否有匹配的值，即两数之和思路
     */
private boolean isValid;
private HashSet<Integer> set = new HashSet<>();

public boolean findTarget(TreeNode root, int k) {
    traverse(root, k);
    return isValid;
}

private void traverse(TreeNode root, int k) {
    if (root == null) {
        return;
    }
    traverse(root.left, k);
    //存在配对，直接返回
    if (set.contains(k - root.val)) {
        isValid = true;
        return;
    } else {
        //不存在加入集合，给别人配对
        set.add(root.val);
    }
    traverse(root.right, k);
}
```

##### [783. 二叉搜索树节点最小距离](https://leetcode.cn/problems/minimum-distance-between-bst-nodes/)

```java
/**
     * 二叉搜索树中序遍历为递增序列，遍历并计算相邻两个节点之间的差值，找到差值最小值
     */
private TreeNode pre;
private int res = Integer.MAX_VALUE;

public int minDiffInBST(TreeNode root) {
    traverse(root);
    return res == Integer.MAX_VALUE ? 0 : res;
}

private void traverse(TreeNode root) {
    if (root == null) {
        return;
    }
    traverse(root.left);
    if (pre != null) {
        res = Math.min(res, root.val - pre.val);
    }
    pre = root;
    traverse(root.right);
}
```

##### [965. 单值二叉树](https://leetcode.cn/problems/univalued-binary-tree/)

```java
/**
* 递归，计算中序遍历时，相邻两个节点的值
*/
TreeNode pre;
public boolean isUnivalTree(TreeNode root) {
    if (root == null) {
        return true;
    }
    boolean left = isUnivalTree(root.left);
    if (pre != null) {
        if (root.val != pre.val) {
            return false;
        }
    }
    pre = root;
    boolean right = isUnivalTree(root.right);
    return left && right;
}
```

##### [LCP 44. 开幕式焰火](https://leetcode.cn/problems/sZ59z6/)

```java
HashSet<Integer> res = new HashSet<>();

public int numColor(TreeNode root) {
    traverse(root);
    return res.size();
}

private void traverse(TreeNode root) {
    if (root == null) {
        return;
    }
    traverse(root.left);
    res.add(root.val);
    traverse(root.right);
}
```

##### [剑指 Offer 27. 二叉树的镜像](https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/)

leetcode -> [226. 翻转二叉树](#to226)

##### [剑指 Offer 28. 对称的二叉树](https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/)

to101

##### [剑指 Offer 32 - II. 从上到下打印二叉树 II](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)

to102

##### [剑指 Offer 55 - I. 二叉树的深度](https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/)

to104

##### [剑指 Offer II 056. 二叉搜索树中两个节点之和](https://leetcode.cn/problems/opLdQZ/)

to653

##### [865. 具有所有最深节点的最小子树](https://leetcode.cn/problems/smallest-subtree-with-all-the-deepest-nodes/)

```java
// 思路：从每个树开始，获得当前节点的左右子树的最大深度
// 深度相同，说明最深的节点在这个节点两边，那这个节点就是结果
// 如果深度不相同，则去深度大的子树继续判断，最终就能得到结果
public TreeNode subtreeWithAllDeepest(TreeNode root) {
    if (root == null) return root;

    // 获取当前节点的左右子树的最大深度
    int leftMaxDepth = getMaxDepth(root.left);
    int rightMaxDepth = getMaxDepth(root.right);

    // 如果两边最大深度相同，则这个节点就是结果
    if (leftMaxDepth == rightMaxDepth) return root;

    // 不相等，那就去深度大的子树那边继续找
    if (leftMaxDepth > rightMaxDepth) {
        return subtreeWithAllDeepest(root.left);
    }

    return subtreeWithAllDeepest(root.right);
}

public int getMaxDepth(TreeNode root) {
    if (root == null) return 0;
    return Math.max(getMaxDepth(root.left), getMaxDepth(root.right)) + 1;
}
```

##### [1123. 最深叶节点的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-deepest-leaves/)

```java
public TreeNode lcaDeepestLeaves(TreeNode root) {
    if (root == null) {
        return null;
    }
    int left = getLongest(root.left);
    int right = getLongest(root.right);
    if (left == right) {
        return root;
    } else if (left > right) {
        return lcaDeepestLeaves(root.left);
    } else {
        return lcaDeepestLeaves(root.right);
    }
}

/**
     * 求树的最大深度
     */
public int getLongest(TreeNode root) {
    if (root == null) {
        return 0;
    }
    return Math.max(getLongest(root.left), getLongest(root.right)) + 1;
}
```

##### [1315. 祖父节点值为偶数的节点和](https://leetcode.cn/problems/sum-of-nodes-with-even-valued-grandparent/)

```java
int sum = 0;
public int sumEvenGrandparent(TreeNode root) {
    traverse(root);
    return sum;
}

public void traverse(TreeNode root) {
    if (root == null) {
        return;
    }
    if (root.val % 2 == 0) {
        if (root.left != null) {
            if (root.left.left != null) {
                sum += root.left.left.val;
            }
            if (root.left.right != null) {
                sum += root.left.right.val;
            }
        }
        if (root.right != null) {
            if (root.right != null) {
                if (root.right.left != null) {
                    sum += root.right.left.val;
                }
                if (root.right.right != null) {
                    sum += root.right.right.val;
                }
            }
        }
    }
    traverse(root.left);
    traverse(root.right);
}
```

##### [1367. 二叉树中的列表](https://leetcode.cn/problems/linked-list-in-binary-tree/)

```java
public boolean isSubPath(ListNode head, TreeNode root) {
    //链表走完返回 true
    if (head == null) {
        return true;
    }
    //树走完，头节结点没走完，返回 false
    if (root == null) {
        return false;
    }
    //从当前根结点开始，或者从左结点或者从右结点开始
    return traverse(root, head) || isSubPath(head, root.left) || isSubPath(head, root.right);
}

public boolean traverse(TreeNode root, ListNode head) {
    if (head == null) {
        return true;
    }
    if (root == null) {
        return false;
    }
    if (root.val != head.val) {
        return false;
    }
    return traverse(root.left, head.next) || traverse(root.right, head.next);
}
```

##### [1379. 找出克隆二叉树中的相同节点](https://leetcode.cn/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/)

```java
TreeNode res;
public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {
    traverse(original, cloned, target);
    return res;
}

public void traverse(TreeNode root, TreeNode cloned, TreeNode target) {
    if (root == null) {
        return;
    }
    if (root == target) {
        res = cloned;
        return;
    }
    traverse(root.left, cloned.left, target);
    traverse(root.right, cloned.right, target);
}
```

##### [1448. 统计二叉树中好节点的数目](https://leetcode.cn/problems/count-good-nodes-in-binary-tree/)

```java
/**
     * 遍历过程中保持一个最大值，当前结点比上一个结点的最大值大，就算做一个好结点
     */
int res = 0;

public int goodNodes(TreeNode root) {
    //当前结点的最大值
    traverse(root, root.val);
    return res;
}


public void traverse(TreeNode root, int val) {
    if (root == null) {
        return;
    }
    //更新当前结点的最大值
    if (root.val >= val) {
        val = root.val;
        res++;
    }
    traverse(root.left, val);
    traverse(root.right, val);
}
```

##### [1462. 课程表 IV](https://leetcode.cn/problems/course-schedule-iv/)

```java
/**
     * 有向无环图，通过记忆化搜索把一个入度结点的所有前置出度结点记录下来
     */
public List<Boolean> checkIfPrerequisite(int numCourses, int[][] prerequisites, int[][] queries) {
    //逆邻接链表
    List<List<Integer>> reverseList = new ArrayList<>();
    HashSet<Integer>[] courses = new HashSet[numCourses];
    for (int i = 0; i < numCourses; i++) {
        reverseList.add(new ArrayList<>());
        courses[i] = new HashSet<>();
    }
    for (int i = 0; i < prerequisites.length; i++) {
        int from = prerequisites[i][0];
        int to = prerequisites[i][1];
        reverseList.get(to).add(from);
    }
    //递归查找没门课程的直接或简介前置课程
    boolean[] isVisited = new boolean[numCourses];
    for (int i = 0; i < numCourses; i++) {
        dfs(i, isVisited, reverseList, courses);
    }
    List<Boolean> res = new ArrayList<>();
    for (int i = 0; i < queries.length; i++) {
        int from = queries[i][0];
        int to = queries[i][1];
        res.add(courses[to].contains(from));
    }
    return res;
}

public void dfs(int num, boolean[] isVisited, List<List<Integer>> graph, HashSet<Integer>[] sets) {
    isVisited[num] = true;
    //寻找当前课程的直接和间接前置课程
    for (int course : graph.get(num)) {
        //如果有前置课程没有被访问过，继续寻找前置课程的前置课程，就是为了确保该课程的所有前置课程的信息都已经存放在 set 中
        if (!isVisited[course]) {
            dfs(course, isVisited, graph, sets);
        }
        //该课程的直接和间接前置课程已经查找过，此时该结点可以拿到直接或间接课程的所有信息
        sets[num].add(course);
        sets[num].addAll(sets[course]);
    }
}
```




#### 动态规划

##### [面试题 17.13. 恢复空格](https://leetcode.cn/problems/re-space-lcci/)

```java
/**
   * 状态定义：dp[i] 表示前 i 个未被识别的最少字符
   * 状态转移：
   * dp[i] = dp[i - 1] + 1 （如果字典中没有字符与之匹配）
   * dp[i] = Math.min(dp[i],dp[i - len]), len 代表字典中每个单词的不同长度
   * 返回值：最终返回 dp[sentence.length()] 代表在句子中未被识别的最少字符数
   * 初始条件：
   */
public int respace(String[] dictionary, String sentence) {
    int[] dp = new int[sentence.length() + 1];
    dp[0] = 0;
    for (int i = 1; i <= sentence.length(); i++) {
        dp[i] = dp[i - 1] + 1;
        for (String str : dictionary) {
            int len = str.length();
            if (i - len < 0) {
                continue;
            }
            if (sentence.substring(i - str.length(), i).equals(str)) {
                dp[i] = Math.min(dp[i], dp[i - str.length()]);
            }
        }
    }
    return dp[sentence.length()];
}
```

##### [279. 完全平方数](https://leetcode.cn/problems/perfect-squares/)

```java
/**
   * 动态规划：获取 1 - n 之间的完全平方数的数组
   * 状态定义：dp[i] 代表位于 i 时的最小完全平方个数
   * 状态转移：dp[i] = min(dp[i],dp[i-1] + 1,dp[i - 4] + 1...)
   */
public int numSquares(int n) {
    ArrayList<Integer> list = new ArrayList<>();
    for (int i = (int) Math.sqrt(n); i > 0; i--) {
        list.add(i * i);
    }
    int[] dp = new int[n + 1];
    Arrays.fill(dp, Integer.MAX_VALUE);
    dp[0] = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j < list.size(); j++) {
            if (i - list.get(j) >= 0) {
                dp[i] = Math.min(dp[i], dp[i - list.get(j)] + 1);
            }
        }
    }
    return dp[n];
}
```

##### [322. 零钱兑换](https://leetcode.cn/problems/coin-change/)

```java
/**
   * 状态定义：dp[i] 凑成 i 元所需要的最小硬币个数
   * 状态转移：dp[i] = min(dp[i - coins[0]] + 1, dp[i - coins[1]] + 1 ...)
   */
public int coinChange(int[] coins, int amount) {
    if (amount == 0) {
        return 0;
    }
    int[] dp = new int[amount + 1];
    Arrays.fill(dp, -1);
    dp[0] = 0;
    for (int i = 1; i <= amount; i++) {
        int temp = Integer.MAX_VALUE;
        for (int j = 0; j < coins.length; j++) {
            if (i - coins[j] >= 0 && dp[i - coins[j]] != -1) {
                temp = Math.min(temp, dp[i - coins[j]] + 1);
            }
        }
        if (temp != Integer.MAX_VALUE) {
            dp[i] = temp;
        }
    }
    return dp[amount];
}
```

##### [787. K 站中转内最便宜的航班](https://leetcode.cn/problems/cheapest-flights-within-k-stops/)

```java
/**
     * 状态定义：f[t][i] 表示通过 t 次航班，从出发城市 src 到达城市 i 需要的最小花费
     * 状态转移：f[t][i] = min(f[t-1][j] + cost[j,i])
     */
//取一半，怕溢出
final int INF = Integer.MAX_VALUE / 2;
public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {
    //最多中转 k 次航班，最多可以乘坐 k + 1 次航班
    int[][] dp = new int[k + 2][n];
    //初始化
    for (int i = 0; i < k + 2; i++) {
        Arrays.fill(dp[i], INF);
    }
    //base case，出发地花费为  0
    dp[0][src] = 0;
    //中转 k 次航班
    for (int i = 1; i <= k + 1; i++) {
        for (int[] flight : flights) {
            int from = flight[0];
            int to = flight[1];
            int cost = flight[2];
            //要么保留当前花费，要么从上一站的终点作为起点，在做一站到最终点
            dp[i][to] = Math.min(dp[i][to], dp[i - 1][from] + cost);
        }
    }
    int res = INF;
    for (int i = 1; i <= k + 1; i++) {
        res = Math.min(res, dp[i][dst]);
    }
    return res == INF ? -1 : res;
}
```





#### 备忘录

##### [139. 单词拆分](https://leetcode.cn/problems/word-break/)

```java
/**
   * 从 0 开始，每次遍历字典，看字典中的单词是否为字符串的前缀
   */
//memo[i] 代表0-i的字符串是否已经被匹配
private int[] memo;
public boolean wordBreak(String s, List<String> wordDict) {
    memo = new int[s.length()];
    Arrays.fill(memo, -1);
    return dp(s, 0, wordDict);
}

private boolean dp(String word, int startIndex, List<String> wordDict) {
    if (startIndex == word.length()) {
        return true;
    }
    //有备忘录则使用
    if (memo[startIndex] != -1) {
        return memo[startIndex] == 1;
    }
    //遍历所有字典，匹配 startIndex~len 的字符串，0-startIndex 的字符串已经匹配过
    for (String str : wordDict) {
        if (str.length() + startIndex > word.length()) {
            continue;
        }
        String subStr = word.substring(startIndex, startIndex + str.length());
        if (!subStr.equals(str)) {
            continue;
        }
        if (dp(word, startIndex + str.length(), wordDict)) {
            memo[startIndex] = 1;
            return true;
        }
    }

    memo[startIndex] = 0;
    return false;
}
```

#### 回溯法

##### [140. 单词拆分 II](https://leetcode.cn/problems/word-break-ii/)

```java
private List<String> list = new ArrayList<>();
public List<String> wordBreak(String s, List<String> wordDict) {
    backtrace(s, 0, wordDict, new StringBuilder());
    return list;
}

private void backtrace(String s, int startIndex, List<String> wordDic, StringBuilder trace) {
    if (startIndex == s.length()) {
        list.add(trace.toString().trim());
        return;
    }
    for (String word : wordDic) {
        int len = word.length();
        if (len + startIndex > s.length()) {
            continue;
        }

        String subStr = s.substring(startIndex, startIndex + len);
        if (!subStr.equals(word)) {
            continue;
        }
        trace.append(word).append(" ");
        backtrace(s, startIndex + len, wordDic, trace);
        //每次会多加一个空格，所以删除的时候要多删除一个字符
        trace.setLength(trace.length() - word.length() - 1);
    }
```

##### [面试题 17.15. 最长单词](https://leetcode.cn/problems/longest-word-lcci/)

```java
/**
   * 回溯法
   * 1. 先对字符串数组排序，长度从长到短，长度相同则按照字典序正序排列
   * 2. 回溯法：通过对一个字符从左到右的截取，该字符串能够由其他单词组成，如果可以，第一个返回的就是最长的单词，因为已经排好序了
   */
public String longestWord(String[] words) {
    List<String> list = Arrays.asList(words);
    list.sort((str1, str2) -> {
        if (str1.length() == str2.length()) {
            return str1.compareTo(str2);
        }
        return -(str1.length() - str2.length());
    });
    String res = "";
    for (String str : list) {
        //已经排好序了，第一个返回的结果一定是最长的
        if (dfs(str, 0, list)) return str;
    }
    return res;
}

/**
   * 在一个字符数组中找出一个长度最长的单词，该单词有数组中其他单词组成
   */
private boolean dfs(String word, int startIndex, List<String> wordList) {
    //找不到已经提早返回 false 了，能走到这里可以返回 true
    if (startIndex == word.length()) {
        return true;
    }
    //从左到右依次截取出 startIndex,word.length() 中的字串，判断是否能被拼接
    for (int i = startIndex; i < word.length(); i++) {
        //不需要和自己对比
        if (i - startIndex + 1 == word.length()) {
            continue;
        }
        String subStr = word.substring(startIndex, i + 1);
        if (!wordList.contains(subStr)) {
            continue;
        }
        //只要找到一种可能就可以返回 true
        if (dfs(word, i + 1, wordList)) {
            return true;
        }
    }
    return false;
}
```

##### [112. 路径总和](https://leetcode.cn/problems/path-sum/)


```java
    /**
     * 回溯：
     * 到达叶子节点时，判断剩余值是否和叶子节点值相同
     */
    private boolean isValid = false;

    public boolean hasPathSum(TreeNode root, int targetSum) {
        if (root == null) {
            return false;
        }
        backtrace(root, targetSum);
        return isValid;
    }

    private void backtrace(TreeNode root, int sum) {
        if (root == null) {
            return;
        }
        //剪枝：已经找到一种满足的情况，后续不需要在做判断
        if (isValid) {
            return;
        }
        if (root.left == null && root.right == null) {
            if (sum == root.val) {
                isValid = true;
            }
        }
        backtrace(root.left, sum - root.val);
        backtrace(root.right, sum - root.val);
    }
```

##### [797. 所有可能的路径](https://leetcode.cn/problems/all-paths-from-source-to-target/)

```java
/**
     * 回溯
     */
List<List<Integer>> res = new LinkedList<>();
public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
    dfs(graph, 0, new LinkedList<>());
    return res;
}

public void dfs(int[][] graph, int index, LinkedList<Integer> list) {
    if (index + 1 == graph.length) {
        list.add(index);
        res.add(new LinkedList<>(list));
        list.removeLast();
        return;
    }
    list.add(index);
    //找到下一个节点数组
    int[] nexts = graph[index];
    for (int next : nexts) {
        dfs(graph, next, list);
    }
    //回溯
    list.removeLast();
}
```

##### [1457. 二叉树中的伪回文路径](https://leetcode.cn/problems/pseudo-palindromic-paths-in-a-binary-tree/)

```java
/**
     * 回溯获取二叉树从根结点到叶子结点的所有路径
     * 符合伪回文路径的字符串应该满足：只有奇数个的数字，其他数字都是偶数
     */
int res = 0;
int[] count = new int[10];

public int pseudoPalindromicPaths(TreeNode root) {
    traverse(root);
    return res;
}

public void traverse(TreeNode root) {
    if (root == null) {
        return;
    }
    if (root.right == null && root.left == null) {
        count[root.val]++;
        //判断是否有大于 1 个奇数个字符
        int total = 0;
        for (int num : count) {
            if (num == 0) {
                continue;
            }
            if (num % 2 == 1) {
                total++;
            }
        }
        if (total <= 1) {
            res++;
        }
        count[root.val]--;
        return;
    }
    count[root.val]++;
    traverse(root.left);
    traverse(root.right);
    count[root.val]--;
    //回溯
}
```





#### 数据结构

##### [208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)

```java
class Trie {
    //字典树结点
    class TrieNode {
        public HashMap<Character, TrieNode> dic = new HashMap<>();
        //记录当前结点是否为一个单词的最后一个字符
        public boolean isWord;
    }

    //根节点
    TrieNode root;

    public Trie() {
        //初始化根节点
        root = new TrieNode();
    }

    public void insert(String word) {
        TrieNode cur = root;
        //遍历插入字符串
        for (char ch : word.toCharArray()) {
            //如果当前结点找不到该字符，说明没有还未保存
            if (cur.dic.get(ch) == null) {
                //将当前字符保存至当前结点
                cur.dic.put(ch, new TrieNode());
            }
            //向下移动至下一个结点
            cur = cur.dic.get(ch);
        }
        //到一个单词结尾时，记录到该位置为一个完整的单词
        cur.isWord = true;
    }

    public boolean search(String word) {
        TrieNode cur = root;
        for (char ch : word.toCharArray()) {
            if (cur.dic.get(ch) == null) {
                return false;
            }
            cur = cur.dic.get(ch);
        }
        //判断当前结点是否为一个单词的结尾，如果是则返回
        return cur.isWord;
    }

    public boolean startsWith(String prefix) {
        TrieNode cur = root;
        for (char ch : prefix.toCharArray()) {
            if (cur.dic.get(ch) == null) {
                return false;
            }
            cur = cur.dic.get(ch);
        }
        //因为判断前缀，无需判断当前结点是否是前缀的最后一个字符，只要不跳出返回 false 即可返回 true
        return true;
    }
}
```

##### [211. 添加与搜索单词 - 数据结构设计](https://leetcode.cn/problems/design-add-and-search-words-data-structure/)

```java
class WordDictionary {
    class WordNode {
        public HashMap<Character, WordNode> dic = new HashMap<>();
        public boolean isWord;
    }

    WordNode root;

    public WordDictionary() {
        root = new WordNode();
    }

    public void addWord(String word) {
        WordNode cur = root;
        for (char ch : word.toCharArray()) {
            if (cur.dic.get(ch) == null) {
                cur.dic.put(ch, new WordNode());
            }
            cur = cur.dic.get(ch);
        }
        cur.isWord = true;
    }

    public boolean search(String word) {
        return dfs(word, 0, root);
    }

    public boolean dfs(String word, int start, WordNode cur) {
        if (start == word.length()) return cur.isWord;
        char ch = word.charAt(start);
        if (ch == '.') {
            for (Map.Entry<Character, WordNode> entry : cur.dic.entrySet()) {
                if(dfs(word, start + 1, entry.getValue())){
                    return true;
                }
            }
            return false;
        } else {
            if (cur.dic.get(ch) == null) {
                return false;
            }
            return dfs(word, start + 1, cur.dic.get(ch));
        }
    }
}
```

##### 并查集

```java
public class UnionFind {
    // 记录连通分量
    private int count;
    // 节点 x 的父节点是 parent[x]
    private int[] parent;

    /* 构造函数，n 为图的节点总数 */
    public UnionFind(int n) {
        this.count = n;
        parent = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }

    // 将节点 p 和节点 q 连通
    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ)
            return;
        parent[rootQ] = rootP;
        // 两个连通分量合并成一个连通分量
        count--;
    }

    // 判断节点 p 和节点 q 是否连通
    public boolean connected(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        return rootP == rootQ;
    }

    /* 返回当前的连通分量个数 */
    public int count() {
        return count;
    }

    /* 返回某个节点 x 的根节点 */
    public int find(int x) {
        if (parent[x] != x) {
            //路径压缩，使得各个 API 时间复杂度为 O(1)
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
}
```

#### 并查集

##### [1971. 寻找图中是否存在路径](https://leetcode.cn/problems/find-if-path-exists-in-graph/)

```java
/**
* 加入并查集，相连需要连接的点后，判断两个节点是否连接
*/
public boolean validPath(int n, int[][] edges, int source, int destination) {
    UnionFind unionFind = new UnionFind(n);
    for (int i = 0; i < edges.length; i++) {
        int pRoot = edges[i][0];
        int qRoot = edges[i][1];
        unionFind.union(pRoot, qRoot);
    }
    return unionFind.connected(source, destination);
}

class UnionFind {
    private int count;
    private int[] parent;

    public UnionFind(int n) {
        this.count = n;
        parent = new int[n];
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
        }
    }

    public void union(int p, int q) {
        int pRoot = find(p);
        int qRoot = find(q);
        if (pRoot == qRoot) {
            return;
        }
        parent[pRoot] = qRoot;
        count--;
    }

    public boolean connected(int p, int q) {
        int pRoot = find(p);
        int qRoot = find(q);
        return pRoot == qRoot;
    }

    public int find(int n) {
        if (parent[n] != n) {
            parent[n] = find(parent[n]);
        }
        return parent[n];
    }
}
```

##### [130. 被围绕的区域](https://leetcode.cn/problems/surrounded-regions/)

```java
/**
     * 并查集，将一个虚拟节点和所有边界的值为 O 的节点相连
     * 遍历矩阵，只能修改不相连的值为 O 的节点
     */
public void solve(char[][] board) {
    int m = board.length;
    int n = board[0].length;
    //矩阵占用 0 - n * m - 1 个节点，虚拟节点占用 n*m 位置
    UnionFind unionFind = new UnionFind(n * m + 1);
    int dummy = n * m;
    //遍历四周边界，将虚拟节点和值为 O 的边界节点相连
    for (int i = 0; i < m; i++) {
        if (board[i][0] == 'O') {
            unionFind.union(dummy, i * n);
        }
        if (board[i][n - 1] == 'O') {
            unionFind.union(dummy, i * n + n - 1);
        }
    }
    for (int i = 0; i < n; i++) {
        if (board[0][i] == 'O') {
            unionFind.union(dummy, i);
        }
        if (board[m - 1][i] == 'O') {
            unionFind.union(dummy, (m - 1) * n + i);
        }
    }
    int[] positionX = new int[]{-1, 1, 0, 0};
    int[] positionY = new int[]{0, 0, 1, -1};
    //遍历，若内部的节点和边界节点相连，会被一起连到虚拟节点下
    for (int i = 1; i < m - 1; i++) {
        for (int j = 1; j < n - 1; j++) {
            if (board[i][j] == 'O') {
                for (int k = 0; k < 4; k++) {
                    int x = i + positionX[k];
                    int y = j + positionY[k];
                    if(board[x][y] == 'O') {
                        unionFind.union(x * n + y, i * n + j);
                    }
                }
            }
        }
    }
    //将所有和虚拟节点不相连的节点由 O 改为 X
    for (int i = 1; i < m - 1; i++) {
        for (int j = 1; j < n - 1; j++) {
            if (!unionFind.connected(dummy, i * n + j)) {
                board[i][j] = 'X';
            }
        }
    }
}

//并查集
class UnionFind {
    private int count;
    private int[] parent;

    public UnionFind(int n) {
        this.count = n;
        //多留出一个位置给虚拟节点
        parent = new int[n];
        for(int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }

    public boolean connected(int q, int p) {
        int pRoot = find(p);
        int qRoot = find(q);
        return pRoot == qRoot;
    }

    public void union(int q, int p) {
        int qRoot = find(q);
        int pRoot = find(p);
        if (qRoot == pRoot) {
            return;
        }
        parent[pRoot] = qRoot;
        count--;
    }

    private int find(int n) {
        if (parent[n] != n) {
            parent[n] = find(parent[n]);
        }
        return parent[n];
    }
}
```

##### [399. 除法求值](https://leetcode.cn/problems/evaluate-division/)

```java
/**
     * 并查集
     */
public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
    HashMap<String, Integer> dic = new HashMap<>(2 * equations.size());
    UnionFind unionFind = new UnionFind(2 * equations.size());
    int index = 0;
    //将字符串和数字映射，数字用于并查集
    for (int i = 0; i < equations.size(); i++) {
        String s1 = equations.get(i).get(0);
        if (!dic.containsKey(s1)) {
            dic.put(s1, index++);
        }
        String s2 = equations.get(i).get(1);
        if (!dic.containsKey(s2)) {
            dic.put(s2, index++);
        }
        //相连
        unionFind.union(dic.get(equations.get(i).get(0)), dic.get(equations.get(i).get(1)), values[i]);
    }
    //做查询
    int size = queries.size();
    double[] res = new double[size];
    for (int i = 0; i < size; i++) {
        String s1 = queries.get(i).get(0);
        String s2 = queries.get(i).get(1);
        if (!dic.containsKey(s1) || !dic.containsKey(s2)) {
            res[i] = -1;
        } else {
            res[i] = unionFind.connected(dic.get(s1), dic.get(s2));
        }
    }
    return res;
}

class UnionFind {
    private int[] parent;
    //指向父节点的权值
    private double[] weight;

    public UnionFind(int n) {
        parent = new int[n];
        weight = new double[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            weight[i] = 1.0d;
        }
    }

    public void union(int p, int q, double value) {
        int pRoot = find(p);
        int qRoot = find(q);
        if (pRoot == qRoot) {
            return;
        }
        parent[pRoot] = qRoot;
        weight[pRoot] = value * weight[q] / weight[p];
    }

    public int find(int n) {
        if (parent[n] != n) {
            int origin = parent[n];
            parent[n] = find(parent[n]);
            weight[n] *= weight[origin];
        }
        return parent[n];
    }

    public double connected(int q, int p) {
        int qRoot = find(q);
        int pRoot = find(p);
        if (pRoot == qRoot) {
            return weight[q] / weight[p];
        } else {
            return -1;
        }
    }
}
```

##### [547. 省份数量](https://leetcode.cn/problems/number-of-provinces/)

```java
/**
     * 并查集：连通后计算连通分量
     */
public int findCircleNum(int[][] isConnected) {
    int m = isConnected.length;
    UnionFind unionFind = new UnionFind(m * m);
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < m; j++) {
            if (isConnected[i][j] == 1) {
                unionFind.union(i, j);
            }
        }
    }
    return m - (m * m - unionFind.count);
}

class UnionFind {
    private int count;
    private int[] parent;

    public UnionFind(int n) {
        this.count = n;
        parent = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }

    public int find(int n) {
        if (parent[n] != n) {
            parent[n] = find(parent[n]);
        }
        return parent[n];
    }

    public void union(int q, int p) {
        int qRoot = find(q);
        int pRoot = find(p);
        if (qRoot == pRoot) {
            return;
        }
        parent[qRoot] = pRoot;
        count--;
    }

    public int count() {
        return count;
    }
}
```

##### [959. 由斜杠划分区域](https://leetcode.cn/problems/regions-cut-by-slashes/)

[leetcode 详细题解](https://leetcode.cn/problems/regions-cut-by-slashes/solution/tu-jie-bing-cha-ji-he-bing-ding-dian-by-bb22r/)

```java
/**
   * 并查集
   */
public int regionsBySlashes(String[] grid) {
    int m = grid.length;
    m++;
    UnionFind unionFind = new UnionFind(m * m + 1);
    int dummy = m * m;
    for (int i = 0; i < m; i++) {
        unionFind.union(dummy, i);
        unionFind.union(dummy, i + (m - 1) * m);
        unionFind.union(dummy, m * i);
        unionFind.union(dummy, m * i + (m - 1));
    }
    int res = 1;
    for (int i = 0; i < grid.length; i++) {
        String str = grid[i];
        for (int j = 0; j < str.length(); j++) {
            char c = str.charAt(j);
            /**
         * 左上角坐标：m * i + j
         * 左下角坐标：m * (i + 1) + j
         * 右上角坐标：m * i + j + 1
         * 右下角坐标：m * (i + 1) + j + 1
         */
            if (c == '\\') {
                boolean union = unionFind.union(m * i + j, m * (i + 1) + j + 1);
                if (!union) {
                    res++;
                }
            } else if (c == '/') {
                boolean union = unionFind.union(m * (i + 1) + j, m * i + j + 1);
                if (!union) {
                    res++;
                }
            }
        }
    }
    return res;
}

class UnionFind {
    private int[] parent;

    public UnionFind(int n) {
        parent = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }

    public boolean union(int q, int p) {
        int pRoot = find(p);
        int qRoot = find(q);
        if (pRoot == qRoot) {
            return false;
        }
        parent[pRoot] = qRoot;
        return true;
    }

    public int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
}
```

##### [1202. 交换字符串中的元素](https://leetcode.cn/problems/smallest-string-with-swaps/)

##### [1319. 连通网络的操作次数](https://leetcode.cn/problems/number-of-operations-to-make-network-connected/)

```java
/**
     * 并查集合
     */
public int makeConnected(int n, int[][] connections) {
    UnionFind unionFind = new UnionFind(n);
    int res = 0;
    for (int[] connection : connections) {
        int val1 = connection[0];
        int val2 = connection[1];
        //已经连通的再次相连，说明该条边会造成环，计算总共有多少条多余的边
        if (unionFind.isConnected(val1, val2)) {
            res++;
            continue;
        }
        unionFind.union(val1, val2);
    }
    //最终连通分量需要将为 1
    int need = unionFind.getCount() - 1;
    return res >= need ? need : -1;
}

```

##### [1559. 二维网格图中探测环](https://leetcode.cn/problems/detect-cycles-in-2d-grid/)

```java
/**
     * 并查集，从左上角开始遍历，每次查找当前位置的下方和右方元素，值相同则相连，已连接则成环
     */
public boolean containsCycle(char[][] grid) {
    int m = grid.length;
    int n = grid[0].length;
    UnionFind unionFind = new UnionFind(m * n);
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (i + 1 < m && grid[i + 1][j] == grid[i][j]) {
                if (unionFind.isConnected(i * n + j, (i + 1) * n + j)) {
                    return true;
                }
                unionFind.union(i * n + j, (i + 1) * n + j);
            }
            if (j + 1 < n && grid[i][j + 1] == grid[i][j]) {
                if (unionFind.isConnected(i * n + j, i * n + j + 1)) {
                    return true;
                }
                unionFind.union(i * n + j, i * n + j + 1);
            }
        }
    }
    return false;
}
```

##### [1631. 最小体力消耗路径](https://leetcode.cn/problems/path-with-minimum-effort/)

```java

/**
     * 并查集，将二维数组的坐标映射到并查集中，假设矩阵有 n 列，坐标为 x,y 映射到并查集中为 x * n + y
     * 将所有的路径加入并查集，并标注该路径的 from 和 to，将路径升序排列后
     * 并查集从小到大将路径上的点相连，若发现左上角 0 和右下角 m*n - 1 相连，则此时的路径长度为最小体力消耗值
     */
public int minimumEffortPath(int[][] heights) {
    List<Triple> edges = new ArrayList<>();
    int m = heights.length;
    int n = heights[0].length;
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (i + 1 < m) {
                int value = Math.abs(heights[i][j] - heights[i + 1][j]);
                edges.add(new Triple(value, i * n + j, (i + 1) * n + j));
            }
            if (j + 1 < n) {
                int value = Math.abs(heights[i][j] - heights[i][j + 1]);
                edges.add(new Triple(value, i * n + j, i * n + j + 1));
            }
        }
    }
    edges.sort(Comparator.comparingInt(a -> a.value));
    UnionFind unionFind = new UnionFind(m * n);
    for (Triple triple : edges) {
        unionFind.union(triple.from, triple.to);
        if (unionFind.isConnected(0, m * n - 1)) {
            return triple.value;
        }
    }
    return 0;
}

class Triple {
    int value;
    int from;
    int to;

    public Triple(int value, int from, int to) {
        this.value = value;
        this.from = from;
        this.to = to;
    }
}
```





#### 思路算法

##### [386. 字典序排数](https://leetcode.cn/problems/lexicographical-numbers/)

```java
/**
   * 遍历 n 次，每次试图将一个数字加入集合，初始数值 number 为 1，加入集合
   * 1. 当 number* 10 <= n，应该优先尝试将 number * 10 加入集合
   * 2. 当 number * 10 > n 时，直接将 number++ 后加入集合。
   * 特殊情况：number % 10 == 9 || number + 1 > n 时。number /= 10 直到不满足条件
   */
public List<Integer> lexicalOrder(int n) {
    List<Integer> res = new ArrayList<>();
    int number = 1;
    for (int i = 0; i < n; i++) {
        res.add(number);
        if (number * 10 <= n) {
            number = number * 10;
        } else {
            while (number + 1 > n || number % 10 == 9) {
                number /= 10;
            }
            number++;
        }
    }
    return res;
}
```
##### [792. 匹配子序列的单词数](https://leetcode.cn/problems/number-of-matching-subsequences/)

```java

/**
     * 初始化，构造 26 个桶，每个单词首字母相同的放入同一个桶中
     */
public int numMatchingSubseq(String s, String[] words) {
    //初始化 26 个桶
    ArrayList<Node>[] arr = new ArrayList[26];
    for (int i = 0; i < 26; i++) {
        arr[i] = new ArrayList<Node>();
    }

    //将首字母相同的放入同一个桶中
    for (String str : words) {
        char ch = str.charAt(0);
        arr[ch - 'a'].add(new Node(0, str));
    }

    int res = 0;
    //遍历字符串，找到该字符对应的桶
    for (char ch : s.toCharArray()) {
        ArrayList<Node> bucket = arr[ch - 'a'];
        arr[ch - 'a'] = new ArrayList<>();
        //遍历该桶内所有单词
        for (int i = 0; i < bucket.size(); i++) {
            Node node = bucket.get(i);
            //将该桶内所有单词的索引后移一位 index++，代表所有字符的 index 位及之前的字符已经成功匹配                
            node.index++;
            //当索引走完时，整个单词完全匹配
            if (node.index == node.word.length()) {
                res++;
            } else {
                //新索引的位置作为起始位置，看该索引后的字符是否能匹配，字符被分配到其他桶
                arr[node.word.charAt(node.index) - 'a'].add(node);
            }
        }
        //原有的桶清空
        bucket.clear();
    }
    return res;
}


class Node {
    int index;
    String word;

    public Node(int index, String word) {
        this.index = index;
        this.word = word;
    }
}
```

##### [1023. 驼峰式匹配](https://leetcode.cn/problems/camelcase-matching/)

```java
/**
     * 遍历字符串：
     * 当 index 走到了模式串的最后一位，字符串还有剩余的，剩余的有不是小写时直接返回 false
     * 当模式串和字符串在 index 处字符相等时，index++；不相等时且不为小写时直接返回 false
     */
public List<Boolean> camelMatch(String[] queries, String pattern) {
    List<Boolean> ans = new ArrayList<>(queries.length);
    for (String query : queries) {
        ans.add(isMatch(query, pattern));
    }
    return ans;
}

public Boolean isMatch(String query, String pattern) {
    int index = 0;
    for (char c : query.toCharArray()) {
        if (index == pattern.length()) {
            if (c < 'a' || c > 'z') {
                return false;
            }
        } else {
            if (c == pattern.charAt(index)) {
                index++;
            } else if (c < 'a' || c > 'z') {
                return false;
            }
        }
    }
    return index == pattern.length();
}
```

##### [365. 水壶问题](https://leetcode.cn/problems/water-and-jug-problem/)

```java
/**
   * 贝祖定理：ax+by=z 有解当且仅当 z 是 x, y 的最大公约数的倍数
   * 寻找两个水壶的最大公约数，判断要的体积是否能被最大公约数整除
   */
public boolean canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) {
    if (jug1Capacity + jug2Capacity < targetCapacity) {
        return false;
    }
    if (jug1Capacity == 0 || jug2Capacity == 0) {
        return targetCapacity == 0 || jug1Capacity + jug2Capacity == targetCapacity;
    }
    return targetCapacity % gcd(jug1Capacity, jug2Capacity) == 0;
}

//辗转相除法求两个非负整数的最大公约数
private int gcd(int num1, int num2) {
    if (num1 < num2) {
        return gcd(num2, num1);
    }
    int reminder = num1 % num2;
    while (reminder != 0) {
        num1 = num2;
        num2 = reminder;
        reminder = num1 % num2;
    }
    return num2;
}
```

##### [449. 序列化和反序列化二叉搜索树](https://leetcode.cn/problems/serialize-and-deserialize-bst/)



##### [672. 灯泡开关 Ⅱ](https://leetcode.cn/problems/bulb-switcher-ii/)

```java
/**
     * 找规律：
     * 前三盏灯的状态决定了其他所有灯泡的状态
     * 假设操作 1 实现了 a 次，操作 2 实现了 b 次，操作 3 实现了 c 次，操作 4 实现了 d 次
     * 对灯泡 1 进行以上操作后
     * 灯泡 1 的状态 = (1 + a + c + d) % 2
     * 灯泡 2 的状态 = (1 + a + b) % 2
     * 灯泡 3 的状态 = (1 + a + c) % 2
     * 灯泡 4 的状态 = (1 + a + b + d) % 2
     * 当灯泡 1 状态 = 灯泡 3 状态时，d 为偶数，灯泡 2 的状态 = 灯泡 4 的状态
     * 当泡 1 状态 != 灯泡 3 状态时，d 为偶数，灯泡 2 的状态 != 灯泡 4 的状态
     * 可以看出前三个灯泡状态决定了后续所有灯泡的状态
     *
     * 解答：
     * 用 (a, b, c)(a,b,c) 来表示前三盏灯的状态。
     * 当 m=0 时，所有灯都亮起，只有一个状态 (1, 1, 1)(1,1,1)。在这种情况下，答案总是 1。
     * 当 m=1 时，得到状态 (0, 0, 0), (1, 0, 1), (0, 1, 0), (0, 1, 1)。在这种情况下，对于灯泡个数 n = 1, 2, 3 的答案是 2, 3, 4
     * 当 m=2 时，检查是否可以获得 7 个状态：即除了(0, 1, 1)之外的所有状态。在这种情况下，n = 1, 2, 3 的答案是 2, 4, 7
     * 当 m=3 时，得到所有 8 个状态。在这种情况下，n = 1, 2, 3 的答案是 2, 4, 8
     */
public int flipLights(int n, int m) {
    n = Math.min(n, 3);
    if (m == 0) return 1;
    if (m == 1) return n == 1 ? 2 : n == 2 ? 3 : 4;
    if (m == 2) return n == 1 ? 2 : n == 2 ? 4 : 7;
    return n == 1 ? 2 : n == 2 ? 4 : 8;
}
```

##### [1267. 统计参与通信的服务器](https://leetcode.cn/problems/count-servers-that-communicate/)

```java
/**
     * 统计每行的机器个数，统计每列的机器个数，再次遍历满足条件的机器数
     */
public int countServers(int[][] grid) {
    int m = grid.length;
    int n = grid[0].length;
    int[] row = new int[m];
    int[] column = new int[n];
    for (int i = 0; i < m; i++) {
        int res = 0;
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == 1) {
                row[i]++;
                column[j]++;
            }
        }
    }
    int res = 0;
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == 1 && (column[j] > 1 || row[i] > 1)) {
                res++;
            }
        }
    }
    return res;
}
```



#### Dijskra

##### [743. 网络延迟时间](https://leetcode.cn/problems/network-delay-time/)

```java
public final int INF = Integer.MAX_VALUE / 2;

public int networkDelayTime(int[][] times, int n, int k) {
    int[][] graph = new int[n + 1][n + 1];
    for (int i = 1; i <= n; i++) {
        Arrays.fill(graph[i], INF);
    }
    for (int i = 0; i < times.length; i++) {
        int from = times[i][0];
        int to = times[i][1];
        int dist = times[i][2];
        graph[from][to] = dist;
    }
    boolean[] isVisited = new boolean[n + 1];
    int[] distTo = new int[n + 1];
    Arrays.fill(distTo, INF);
    distTo[k] = 0;

    for (int i = 1; i <= n; i++) {
        int x = -1;
        for (int j = 1; j <= n; j++) {
            if (!isVisited[j] && (x == -1 || distTo[j] < distTo[x])) {
                x = j;
            }
        }
        isVisited[x] = true;
        for (int j = 1; j <= n; j++) {
            distTo[j] = Math.min(distTo[j], distTo[x] + graph[x][j]);
        }
    }
    int res = 0;
    for (int i = 1; i <= n; i++) {
        res = Math.max(res,distTo[i]);
    }
    return res == INF ? -1 : res;
}
```

#### 二分图

##### [785. 判断二分图](https://leetcode.cn/problems/is-graph-bipartite/)

```java
// 记录图是否符合二分图性质
private boolean ok = true;
// 记录图中节点的颜色，false 和 true 代表两种不同颜色
private boolean[] color;
// 记录图中节点是否被访问过
private boolean[] visited;

// 主函数，输入邻接表，判断是否是二分图
public boolean isBipartite(int[][] graph) {
    int n = graph.length;
    color = new boolean[n];
    visited = new boolean[n];
    // 因为图不一定是联通的，可能存在多个子图
    // 所以要把每个节点都作为起点进行一次遍历
    // 如果发现任何一个子图不是二分图，整幅图都不算二分图
    for (int v = 0; v < n; v++) {
        if (!visited[v]) {
            traverse(graph, v);
        }
    }
    return ok;
}

// DFS 遍历框架
private void traverse(int[][] graph, int v) {
    // 如果已经确定不是二分图了，就不用浪费时间再递归遍历了
    if (!ok) return;
    visited[v] = true;
    for (int w : graph[v]) {
        if (!visited[w]) {
            // 相邻节点 w 没有被访问过
            // 那么应该给节点 w 涂上和节点 v 不同的颜色
            color[w] = !color[v];
            // 继续遍历 w
            traverse(graph, w);
        } else {
            // 相邻节点 w 已经被访问过
            // 根据 v 和 w 的颜色判断是否是二分图
            if (color[w] == color[v]) {
                // 若相同，则此图不是二分图
                ok = false;
                return;
            }
        }
    }
}
```

##### [886. 可能的二分法](https://leetcode.cn/problems/possible-bipartition/)

```java
/**
     * 二分图
     */
boolean[] isVisited;
boolean[] color;
boolean isValid = true;
public boolean possibleBipartition(int n, int[][] dislikes) {
    color = new boolean[n + 1];
    isVisited = new boolean[n + 1];
    //构建邻接链表
    List<List<Integer>> graph = new LinkedList<>();
    for (int i = 0; i < n + 1; i++) {
        graph.add(new LinkedList<>());
    }
    for (int[] arr : dislikes) {
        int val1 = arr[0];
        int val2 = arr[1];
        graph.get(val1).add(val2);
        graph.get(val2).add(val1);
    }
    for (int i = 1; i <= n; i++) {
        if(!isVisited[i]) {
            bfs(graph, i);
        }
    }
    return isValid;
}

public void bfs(List<List<Integer>> graph, int x) {
    if (!isValid) {
        return;
    }
    isVisited[x] = true;
    for (int next : graph.get(x)) {
        //没被涂过，颜色涂成不一样
        if (!isVisited[next]) {
            color[next] = !color[x];
            bfs(graph, next);
            //被涂过，看颜色是否不同
        } else {
            if (color[next] == color[x]) {
                isValid = false;
            }
        }
    }
}
```

#### 贪心

```java
/**
     * 贪心算法
     */
public int[] gardenNoAdj(int n, int[][] paths) {
    int[] flowers = new int[]{1, 2, 3, 4};
    List<List<Integer>> graph = new ArrayList<>();
    HashSet<Integer>[] sets = new HashSet[n];
    int[] res = new int[n];
    for (int i = 0; i < n; i++) {
        graph.add(new ArrayList<>());
        sets[i] = new HashSet<>();
    }
    //构建邻接链表
    for (int[] arr : paths) {
        int val1 = arr[0];
        int val2 = arr[1];
        graph.get(val1 - 1).add(val2 - 1);
        graph.get(val2 - 1).add(val1 - 1);
    }
    //遍历所有花园
    for (int i = 0; i < n; i++) {
        //随便选出一朵花
        for (int flower : flowers) {
            //如果这朵花已经被种植了，换另外一朵
            if (!sets[i].contains(flower)) {
                //没被种植过的花种在当前花园里
                res[i] = flower;
                //更新和当前花园连通的，编号比当前花园更大的花园，编号比当前花园小的花园已经确定种什么花了
                for (int dest : graph.get(i)) {
                    if (dest > i) {
                        //编号比当前花园更大的花园以后一定不能种植编号为 flower 的花朵
                        sets[dest].add(flower);
                    }
                }
                break;
            }
        }
    }
    return res;
}
```

