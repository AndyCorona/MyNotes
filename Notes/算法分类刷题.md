#### 前缀树

##### [421. 数组中两个数的最大异或值](https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/)<span id="to421"></span>

```java
/**
   * 获取 int 数的二进制表示
   * 1.构建字典树，将所有的数字的二进制形式加入字典树
   * 2.从字典树根节点开始遍历每个数字 ai，如果 ai 的第 k 位是 0，应该往 1 结点走，否则应该往 0 结点走
   * 3.遍历所有数字之后，返回最大值
   */
public int findMaximumXOR(int[] nums) {
    Trie trie = new Trie();
    int res = 0;
    StringBuilder builder = new StringBuilder();
    //加入前 i 个数字后，第 i + 1 个数字立即去计算异或值
    for (int i = 1; i < nums.length; i++) {
        trie.insert(nums[i - 1]);
        res = Math.max(res, cal(nums[i], trie.root));
        builder.setLength(0);
    }
    return res;
}

private int cal(int num, Trie.TrieNode root) {
    int res = 0;
    for (int i = 30; i >= 0; i--) {
        //从最高位一直取到最低位
        int bit = (num >> i) & 1;
        if (bit == 1) {
            if (root.left != null) {
                root = root.left;
                //注意优先级：res << 1 + 1 == res << 2
                res = (res << 1) + 1;
            } else {
                res = res << 1;
                root = root.right;
            }
        } else if (bit == 0) {
            if (root.right != null) {
                res = (res << 1) + 1;
                root = root.right;
            } else {
                res = res << 1;
                root = root.left;
            }
        }
    }
    return res;
}

class Trie {
    class TrieNode {
        public TrieNode left;
        public TrieNode right;
    }

    public TrieNode root;

    public Trie() {
        root = new TrieNode();
    }

    /**
   * 向前缀树中插入一个 int 二进制数，例如 0000000000000000000000000010110
   * left 为 true 代表 0, right 为 true 代表 1
   */
    public void insert(int number) {
        TrieNode cur = root;
        for (int i = 30; i >= 0; i--) {
            //从最高位一直取到最低位
            int bit = (number >> i) & 1;
            if (bit == 0) {
                if (cur.left != null) {
                    cur = cur.left;
                    continue;
                }
                cur.left = new TrieNode();
                cur = cur.left;
            } else if (bit == 1) {
                if (cur.right != null) {
                    cur = cur.right;
                    continue;
                }
                cur.right = new TrieNode();
                cur = cur.right;
            }
        }
    }
}
```

##### [648. 单词替换](https://leetcode.cn/problems/replace-words/)<span id = "to648"></span>

```java
/**
   * 前缀树：
   * 遍历句子中的每个单词，若单词可以到达一个前缀树末尾（每个词根都有末尾），替换，否则不替换
   */
public String replaceWords(List<String> dictionary, String sentence) {
    Trie trie = new Trie();
    for (String str : dictionary) {
        trie.insert(str);
    }
    String[] split = sentence.split(" ");
    StringBuilder res = new StringBuilder();
    for (String str : split) {
        String successor = trie.isSuccessor(str);
        res.append(successor);
        res.append(" ");
    }
    return res.toString().trim();
}
class Trie {
    class TrieNode {
        public HashMap<Character, TrieNode> dic = new HashMap<>();
        boolean isEnd;
    }

    TrieNode root;

    public Trie() {
        this.root = new TrieNode();
    }

    public void insert(String word) {
        TrieNode cur = root;
        for (char c : word.toCharArray()) {
            if (cur.dic.get(c) == null) {
                cur.dic.put(c, new TrieNode());
            }
            cur = cur.dic.get(c);
        }
        cur.isEnd = true;
    }

    public String isSuccessor(String word) {
        StringBuilder res = new StringBuilder();
        TrieNode cur = root;
        for (char c : word.toCharArray()) {
            if (cur.dic.get(c) == null) {
                break;
            }
            res.append(c);
            cur = cur.dic.get(c);
            //已经到达一个单词末尾，立即跳出
            if (cur.isEnd) {
                return res.toString();
            }
        }
        return cur.isEnd ? res.toString() : word;
    }
}
```

##### [676. 实现一个魔法字典](https://leetcode.cn/problems/implement-magic-dictionary/) <span id="to676"></span>

```java
class MagicDictionary {
    class TrieNode {
        public HashMap<Character, TrieNode> dic = new HashMap<>();
        public boolean isEnd;
    }

    TrieNode root;

    public MagicDictionary() {
        root = new TrieNode();
    }

    public void buildDict(String[] dictionary) {
        for (String str : dictionary) {
            TrieNode cur = root;
            for (char ch : str.toCharArray()) {
                if (cur.dic.get(ch) == null) {
                    cur.dic.put(ch, new TrieNode());
                }
                cur = cur.dic.get(ch);
            }
            cur.isEnd = true;
        }
    }

    public boolean search(String searchWord) {
        return dfs(searchWord, root 0, false);
    }

    public boolean dfs(TrieNode cur, String searchWord, int startIndex, boolean isModified) {
        if (startIndex == searchWord.length()) {
            //必须要修改过且是一个单词
            return isModified && cur.isEnd;
        }
        char c = searchWord.charAt(startIndex);
        if (cur.dic.get(c) != null) {
            //继续匹配下一个字符，后续只要有一种情况返回 true，就返回 true
            if (dfs(cur.dic.get(c), searchWord, startIndex + 1, isModified)) {
                return true;
            }
        }
        //没有修改过的话，尝试修改，后续只要有一种情况返回 true，就返回 true
        if (!isModified) {
            for (Map.Entry<Character, TrieNode> entry : cur.dic.entrySet()) {
                char ch = entry.getKey();
                //不需要和自己再次匹配
                if (cur.dic.get(ch) != null) {
                    if (dfs(cur, searchWord, startIndex + 1, true)) {
                        return true;
                    }
                }
            }
        }
        //所有可能性都匹配完了，只能返回 false
        return false;
    }
}
```

##### [677. 键值映射](https://leetcode.cn/problems/map-sum-pairs/) <span id = "to677"></span>

```java
/**
 * 前缀树
 */
class MapSum {
    class TrieNode {
        public HashMap<Character, TrieNode> dic = new HashMap<>();
        public int value;
    }

    TrieNode root;
    //存放前缀字符串对应的值
    HashMap<String, Integer> map;

    public MapSum() {
        root = new TrieNode();
        map = new HashMap<>();
    }

    public void insert(String key, int val) {
        //例如原本前缀 abc 值为 3，则 a->b->c 的路径上的值都为 3，现在更改为 2，则 delta = -1，a->b->c 路径上的值都应该减 1
        int delta = val - map.getOrDefault(key, 0);
        map.put(key, val);
        TrieNode cur = root;
        for (char ch : key.toCharArray()) {
            if (cur.dic.get(ch) == null) {
                cur.dic.put(ch, new TrieNode());
            }
            cur = cur.dic.get(ch);
            //数值修补
            cur.value += delta;
        }
    }
	//直接获取某个节点的值
    public int sum(String prefix) {
        TrieNode cur = root;
        for (char ch : prefix.toCharArray()) {
            if (cur.dic.get(ch) == null) {
                return 0;
            }
            cur = cur.dic.get(ch);
        }
        return cur.value;
    }
}
```

##### [720. 词典中最长的单词](https://leetcode.cn/problems/longest-word-in-dictionary/)

```java
/**
   * 所有单词加入前缀树，遍历，找到符合条件的最长单词
   */
public String longestWord(String[] words) {
    Trie trie = new Trie();
    for (int i = 0; i < words.length; i++) {
        trie.insert(words[i]);
    }
    String res = "";
    for (int i = 0; i < words.length; i++) {
        String search = trie.search(words[i]);
        if (search != null) {
            //长度相同按照字典序排序
            if (search.length() == res.length()) {
                res = res.compareTo(search) < 0 ? res : search;
            } else if (search.length() > res.length()) {
                res = search;
            }
        }
    } return res;
}

class Trie {
    class TrieNode {
        public TreeMap<Character, TrieNode> dic = new TreeMap<>();
        public boolean isWord;
    }

    TrieNode root;

    public Trie() {
        this.root = new TrieNode();
    }

    public void insert(String word) {
        TrieNode cur = root;
        for (char ch : word.toCharArray()) {
            if (cur.dic.get(ch) == null) {
                cur.dic.put(ch, new TrieNode());
            }
            cur = cur.dic.get(ch);
        }
        cur.isWord = true;
    }

    public String search(String word) {
        TrieNode cur = root;
        for (char ch : word.toCharArray()) {
            if (cur.dic.get(ch) == null) {
                return "";
            }
            cur = cur.dic.get(ch);
            if (!cur.isWord) {
                return "";
            }
        }
        return word;
    }
}
```

##### [792. 匹配子序列的单词数](https://leetcode.cn/problems/number-of-matching-subsequences/)

```java
/**
     * 初始化，构造 26 个桶，每个单词首字母相同的放入同一个桶中
     */
public int numMatchingSubseq(String s, String[] words) {
    //初始化 26 个桶
    ArrayList<Node>[] arr = new ArrayList[26];
    for (int i = 0; i < 26; i++) {
        arr[i] = new ArrayList<Node>();
    }

    //将首字母相同的放入同一个桶中
    for (String str : words) {
        char ch = str.charAt(0);
        arr[ch - 'a'].add(new Node(0, str));
    }

    int res = 0;
    //遍历字符串，找到该字符对应的桶
    for (char ch : s.toCharArray()) {
        ArrayList<Node> bucket = arr[ch - 'a'];
        arr[ch - 'a'] = new ArrayList<>();
        //遍历该桶内所有单词
        for (int i = 0; i < bucket.size(); i++) {
            Node node = bucket.get(i);
            //将该桶内所有单词的索引后移一位 index++，代表所有字符的 index 位及之前的字符已经成功匹配                
            node.index++;
            //当索引走完时，整个单词完全匹配
            if (node.index == node.word.length()) {
                res++;
            } else {
                //新索引的位置作为起始位置，看该索引后的字符是否能匹配，字符被分配到其他桶
                arr[node.word.charAt(node.index) - 'a'].add(node);
            }
        }
        //原有的桶清空
        bucket.clear();
    }
    return res;
}


class Node {
    int index;
    String word;

    public Node(int index, String word) {
        this.index = index;
        this.word = word;
    }
}
```

##### [820. 单词的压缩编码](https://leetcode.cn/problems/short-encoding-of-words/) <span id = "to820"></span>

```java
/**
     * 单词反转后插入字典树
     * 统计所有叶子节点代表的单词长度即为答案
     */
public int minimumLengthEncoding(String[] words) {
    Trie trie = new Trie();
    StringBuilder builder = new StringBuilder();
    for (String str : words) {
        trie.insert(builder.append(str).reverse().toString());
        builder.setLength(0);
    }
    trie.traverse();
    return trie.res;
}

class Trie {
    class TrieNode {
        public HashMap<Character, TrieNode> dic = new HashMap<>();
        public boolean isEnd;
    }

    TrieNode root;

    public Trie() {
        this.root = new TrieNode();
    }

    public void insert(String word) {
        TrieNode cur = root;
        for (char ch : word.toCharArray()) {
            if (cur.dic.get(ch) == null) {
                cur.dic.put(ch, new TrieNode());
            }
            cur = cur.dic.get(ch);
        }
        cur.isEnd = true;
    }

    int res = 0;

    //遍历前缀树，到叶子节点时计算值
    public int traverse() {
        TrieNode cur = root;
        traverse(root, 1);
        return res;
    }

    public void traverse(TrieNode node, int index) {
        if (node.isEnd && node.dic.isEmpty()) {
            res += index;
            return;
        }
        for (Map.Entry<Character, TrieNode> entry : node.dic.entrySet()) {
            char ch = entry.getKey();
            traverse(node.dic.get(ch), index + 1);
        }
    }
}
```

##### [1233. 删除子文件夹](https://leetcode.cn/problems/remove-sub-folders-from-the-filesystem/)

```java
/**
     * 前缀树，节点保存一层目录的目录名
     */
public List<String> removeSubfolders(String[] folder) {
    Trie trie = new Trie();
    //建树
    for (String i : folder) {
        trie.add(i);
    }
    //遍历所有字符串
    List<String> ans = new ArrayList<>();
    for (String i : folder) {
        if (trie.search(i)) {
            ans.add(i);
        }
    }
    return ans;
}
}

class Trie {
    HashMap<String, Trie> child;
    boolean isEnd;

    public Trie() {
        this.child = new HashMap<>();
        this.isEnd = false;
    }

    public void add(String s) {
        Trie root = this;
        String[] arr = s.split("/");
        for (int i = 0; i < arr.length; i++) {
            if (!root.child.containsKey(arr[i])) {
                root.child.put(arr[i], new Trie());
            }
            root = root.child.get(arr[i]);
        }
        root.isEnd = true;
    }

    public boolean search(String s) {
        Trie root = this;
        String[] arr = s.split("/");
        for (int i = 0; i < arr.length; i++) {
            root = root.child.get(arr[i]);
            // /a/b 还未到达末尾的时候 root.isEnd = true 说明 /a 存在，所以 /a/b 是子目录
            if (i != arr.length - 1 && root.isEnd) {
                return false;
            }
        }
        return true;
    }
```

##### [1268. 搜索推荐系统](https://leetcode.cn/problems/search-suggestions-system/)

```java
/**
* 前缀树+DFS
*/
public List<List<String>> suggestedProducts(String[] products, String searchWord) {
    List<List<String>> res = new ArrayList<>();
    Trie trie = new Trie();
    //建树
    for (String str : products) {
        trie.add(str);
    }
    //所有可能的输入字符串
    for (int i = 1; i <= searchWord.length(); i++) {
        String subStr = searchWord.substring(0, i);
        List<String> search = trie.search(subStr);
        res.add(search);
    }
    return res;
}
class Trie {

    class TrieNode {
        TreeMap<Character, TrieNode> child = new TreeMap<>();
        boolean isEnd;
    }

    TrieNode root;

    public Trie() {
        root = new TrieNode();
    }

    public void add(String s) {
        TrieNode cur = root;
        for (char ch : s.toCharArray()) {
            if (cur.child.get(ch) == null) {
                cur.child.put(ch, new TrieNode());
            }
            cur = cur.child.get(ch);
        }
        cur.isEnd = true;
    }
	
    public List<String> search(String s) {
        TrieNode cur = root;
        List<String> list = new ArrayList<>();
        dfs(s, 0, root, list, new StringBuilder());
        return list;
    }

    //输入一个字符串，dfs 前缀树
    public void dfs(String s, int startIndex, TrieNode cur, List<String> list, StringBuilder builder) {
        //已经获取三个相关单词
        if (list.size() == 3) {
            return;
        }
        //输入 abc，获取 abcd 的字符串，长度必须大于输入字符串
        if (cur.isEnd && startIndex >= s.length()) {
            list.add(builder.toString());
        }
        //前缀树遍历 base case
        if (cur.child.isEmpty()) {
            return;
        }
       	//多叉树，需要过滤
        for (Map.Entry<Character, TrieNode> entry : cur.child.entrySet()) {
            char ch = entry.getKey();
            //过滤 key
            if (startIndex >= s.length() || ch == s.charAt(startIndex)) {
                builder.append(ch);
                dfs(s, startIndex + 1, cur.child.get(ch), list, builder);
                builder.setLength(builder.length() - 1);
            }
        }
    }
}
```

##### [剑指 Offer II 063. 替换单词](https://leetcode.cn/problems/UhWRSj/)

leetcode -> [648. 单词替换](#to648)

##### [剑指 Offer II 065. 最短的单词编码](https://leetcode.cn/problems/iSwD2y/)

leetcoed -> [820. 单词的压缩编码](#to820)

##### [剑指 Offer II 066. 单词之和](https://leetcode.cn/problems/z1R5dt/)

leetcode -> [剑指 Offer II 066. 单词之和](#to677)

##### [剑指 Offer II 064. 神奇的字典](https://leetcode.cn/problems/US1pGT/)

leetcode -> [676. 实现一个魔法字典](#to676)

##### [剑指 Offer II 067. 最大的异或](https://leetcode.cn/problems/ms70jA/)

leetcode -> [421. 数组中两个数的最大异或值](#to421)

##### [面试题 16.02. 单词频率](https://leetcode.cn/problems/words-frequency-lcci/)

```		java
class WordsFrequency {
    HashMap<String, Integer> dic = new HashMap<>();

    public WordsFrequency(String[] book) {
        for (String str : book) {
            dic.put(str, dic.getOrDefault(str, 0) + 1);
        }
    }
    
    public int get(String word) {
         return dic.getOrDefault(word, 0);
    }
}
```

##### [面试题 17.17. 多次搜索](https://leetcode.cn/problems/multi-search-lcci/)

```java
public int[][] multiSearch(String big, String[] smalls) {
    TrieNode root = new TrieNode();
    Map<String, List<Integer>> map = new HashMap<>();
    //将短字符串反转后构建字典树
    for (String small : smalls) {
        map.put(small, new ArrayList<>());
        insert(root, small);
    }
    //寻找所有单词在big中的起始位置，并存放在map中
    for (int i = 0; i < big.length(); i++) {
        search(root, i, big, map);
    }
    //输出结果
    int[][] ans = new int[smalls.length][];
    for (int i = 0; i < smalls.length; i++) {
        ans[i] = map.get(smalls[i]).stream().mapToInt(Integer::valueOf).toArray();
    }
    return ans;
}

//构建后缀树
public void insert(TrieNode root, String word) {
    TrieNode cur = root;
    //倒序插入前缀树
    for (int i = word.length() - 1; i >= 0; i--) {
        char ch = word.charAt(i);
        if (cur.child.get(ch) == null) {
            cur.child.put(ch, new TrieNode());
        }
        cur = cur.child.get(ch);
    }
    cur.isWord = true; //表示单词的结尾
}

//寻找以endPos结尾的所有单词的起始位置
public void search(TrieNode root, int endPos, String sentence, Map<String, List<Integer>> map) {
    TrieNode cur = root;
    StringBuilder builder = new StringBuilder(); //单词作为key
    for (int i = endPos; i >= 0; i--) {
        char ch = sentence.charAt(i);
        if (cur.child.get(ch) == null) {
            break;
        }
        //由于字典树存的是后缀，故要倒着插入
        builder.insert(0, sentence.charAt(i));
        //往后寻找
        cur = cur.child.get(ch);
        //找到某个单词，就把起始位置添加到map中
        if (cur.isWord) {
            map.get(builder.toString()).add(i);
        }
    }
}

class TrieNode {
    HashMap<Character, TrieNode> child;
    boolean isWord;

    public TrieNode() {
        child = new HashMap();
    }
}
```

#### BFS

##### [111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

```java
/**
* 层序遍历，遇到第一个左右子结点都为 null 的节点即为最小深度
*/
public int minDepth(TreeNode root) {

    if (root == null) {
        return 0;
    }

    LinkedList<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int index = 1;
    while (!queue.isEmpty()) {
        int sz = queue.size();
        for (int i = 0; i < sz; i++) {
            TreeNode cur = queue.poll();
            if (cur.left == null && cur.right == null) {
                return index;
            }
            if (cur.left != null) {
                queue.offer(cur.left);
            }
            if (cur.right != null) {
                queue.offer(cur.right);
            }
        }
        index++;
    }
    return 0;
}
```

##### [637. 二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)

```java
public List<Double> averageOfLevels(TreeNode root) {
    LinkedList<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    List<Double> list = new ArrayList<>();
    while (!queue.isEmpty()) {
        int sz = queue.size();
        double sum = 0;
        for (int i = 0; i < sz; i++) {
            TreeNode poll = queue.poll();
            sum += poll.val;
            if (poll.left != null) {
                queue.offer(poll.left);
            }
            if (poll.right != null) {
                queue.offer(poll.right);
            }
        }
        list.add(sum / sz);
    }
    return list;
}
```

##### [993. 二叉树的堂兄弟节点](https://leetcode.cn/problems/cousins-in-binary-tree/)

```java
/**
     * BFS，获取两个节点的父节点和层级，判断即可
     */
public boolean isCousins(TreeNode root, int x, int y) {
    if (root == null) {
        return false;
    }
    int heightX = 0;
    int heightY = 0;
    TreeNode levelX = null;
    TreeNode levelY = null;
    int level = 1;
    LinkedList<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        int sz = queue.size();
        for (int i = 0; i < sz; i++) {
            TreeNode poll = queue.poll();
            if (poll.left != null) {
                queue.offer(poll.left);
                if (poll.left.val == x) {
                    heightX = level;
                    levelX = poll;
                }
                if (poll.left.val == y) {
                    heightY = level;
                    levelY = poll;
                }
            }
            if (poll.right != null) {
                queue.offer(poll.right);
                if (poll.right.val == x) {
                    heightX = level;
                    levelX = poll;
                }
                if (poll.right.val == y) {
                    heightY = level;
                    levelY = poll;
                }
            }
        }
        if (levelX != null && levelY != null) {
            break;
        }
        level++;
    }
    return (heightX == heightY) && (levelX != levelY);
}
```





#### DFS

[463. 岛屿的周长](https://leetcode.cn/problems/island-perimeter/)

```java
/**
     * DFS：从第一个陆地开始 dfs，访问过的陆地值改为 2。由陆地向四方搜索，如果四方是水域或超出边界，则周长+1
     */
private int res = 0;
public int islandPerimeter(int[][] grid) {
    int m = grid.length;
    int n = grid[0].length;
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == 1) {
                dfs(grid, i, j);
            }
        }
    }
    return res;
}

private void dfs(int[][] grid, int x, int y) {
    //超过边界
    if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[x][y] == 0) {
        res++;
        return;
    }
    //该点已经访问过了
    if (grid[x][y] == 2) {
        return;
    }
    //该点标记为访问过
    grid[x][y] = 2;
    //向四个方向走动，看是否为水域，如果为水域或超出边界，则++
    dfs(grid, x - 1, y);
    dfs(grid, x + 1, y);
    dfs(grid, x, y - 1);
    dfs(grid, x, y + 1);
}
```

##### [733. 图像渲染](https://leetcode.cn/problems/flood-fill/)

```java
int[] direactionX = new int[]{-1, 1, 0, 0};
int[] direactionY = new int[]{0, 0, 1, -1};
public int[][] floodFill(int[][] image, int sr, int sc, int color) {
    if (image[sr][sc] == color) {
        return image;
    }
    dfs(image, sr, sc, image[sr][sc], color);
    return image;
}

private void dfs(int[][] grid, int x, int y, int srcColor, int color) {
    if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[x][y] != srcColor) {
        return;
    }
    grid[x][y] = color;
    for (int i = 0; i < 4; i++) {
        dfs(grid, x + direactionX[i], y + direactionY[i], srcColor, color);
    }
}
```

##### [LCP 07. 传递信息](https://leetcode.cn/problems/chuan-di-xin-xi/)

```java
```



#### 树-递归或迭代

##### [100. 相同的树](https://leetcode.cn/problems/same-tree/)

```java
/**
* 两棵树的左右结点相同且两棵数的结点值相同，或两棵树都为 null 才返回 true
*/
public boolean isSameTree(TreeNode p, TreeNode q) {
    if (p == null && q == null) {
        return true;
    }
    if (p == null || q == null) {
        return false;
    }
    if (p.val != q.val) {
        return false;
    }
    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
}
```

##### [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

```java
public boolean isSymmetric(TreeNode root) {
    if (root == null) {
        return true;
    }
    return traverse(root.left, root.right);
}

/**
   * 左右结点必须值相同，且左右结点也为对称的树
   */
public boolean traverse(TreeNode left, TreeNode right) {
    if (left == null && right == null) {
        return true;
    }
    if (left == null || right == null) {
        return false;
    }
    return left.val == right.val && traverse(left.left, right.right) && traverse(left.right, right.left);
}
```

##### ##### [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

```java
private int res = 0;
public int maxDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    traverse(root, 0);
    return res;
}

public void traverse(TreeNode root, int index) {
    if (root == null) {
        res = Math.max(res, index);
        return;
    }
    traverse(root.left, index + 1);
    traverse(root.right, index + 1);
}
```

##### [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

```java
public TreeNode invertTree(TreeNode root) {
    if (root == null) {
        return null;
    }
    return traverse(root);
}

private TreeNode traverse(TreeNode root) {
    if (root == null) {
        return null;
    }
    //左子树已经翻转完毕
    TreeNode left = traverse(root.left);
    //左子树已经翻转完毕
    TreeNode right = traverse(root.right);
    //左右节点交换
    root.right = left;
    root.left = right;
    return root;
}
```

##### [404. 左叶子之和](https://leetcode.cn/problems/sum-of-left-leaves/)

```java
private int res;
public int sumOfLeftLeaves(TreeNode root) {
    traverse(root);
    return res;
}

private void traverse(TreeNode root) {
    if (root == null) {
        return;
    }
    //当前节点的左节点
    if (root.left != null) {
        //当前节点的左节点是叶子节点
        if (root.left.left == null && root.left.right == null) {
            res += root.left.val;
        }
    }
    traverse(root.left);
    traverse(root.right);

}
```

##### [530. 二叉搜索树的最小绝对差](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)

```java
/**
     * 二叉搜索树的中序遍历为递增序列，中序遍历即可，遍历过程需要一个节点记录上一个节点
     */
private int res = Integer.MAX_VALUE;
private TreeNode pre;

public int getMinimumDifference(TreeNode root) {
    traverse(root);
    return res;
}

private void traverse(TreeNode cur) {
    if (cur == null) {
        return;
    }
    traverse(cur.left);
    if (pre != null) {
        res = Math.min(res, (cur.val - pre.val));
    }
    //更新下一个节点
    pre = cur;
    traverse(cur.right);
}
```

##### [559. N 叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/)

```java
private int res = 0;
public int maxDepth(Node root) {
    traverse(root, 1);
    return res;
}

private void traverse(Node root, int index) {
    if (root == null) {
        return;
    }
    //多叉树的叶子节点
    if (root.children.isEmpty()) {
        res = Math.max(res, index);
    }
    for (int i = 0; i < root.children.size(); i++) {
        traverse(root.children.get(i), index + 1);
    }
}
```

##### [617. 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/)

```java
/**
* 递归
*/
public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
    if (root1 == null ){
        return root2;
    }
    if (root2 == null) {
        return root1;
    }
    root1.val += root2.val;
    root1.left = mergeTrees(root1.left, root2.left);
    root1.right = mergeTrees(root1.right, root2.right);
    return root1;
}
```

##### [653. 两数之和 IV - 输入 BST](https://leetcode.cn/problems/two-sum-iv-input-is-a-bst/)

```java
/**
     * 二叉搜索树的中序遍历为递增序列，set 保存获取的值，每获取到一个节点值时去 set 寻找是否有匹配的值，即两数之和思路
     */
private boolean isValid;
private HashSet<Integer> set = new HashSet<>();

public boolean findTarget(TreeNode root, int k) {
    traverse(root, k);
    return isValid;
}

private void traverse(TreeNode root, int k) {
    if (root == null) {
        return;
    }
    traverse(root.left, k);
    //存在配对，直接返回
    if (set.contains(k - root.val)) {
        isValid = true;
        return;
    } else {
        //不存在加入集合，给别人配对
        set.add(root.val);
    }
    traverse(root.right, k);
}
```

##### [783. 二叉搜索树节点最小距离](https://leetcode.cn/problems/minimum-distance-between-bst-nodes/)

```java
/**
     * 二叉搜索树中序遍历为递增序列，遍历并计算相邻两个节点之间的差值，找到差值最小值
     */
private TreeNode pre;
private int res = Integer.MAX_VALUE;

public int minDiffInBST(TreeNode root) {
    traverse(root);
    return res == Integer.MAX_VALUE ? 0 : res;
}

private void traverse(TreeNode root) {
    if (root == null) {
        return;
    }
    traverse(root.left);
    if (pre != null) {
        res = Math.min(res, root.val - pre.val);
    }
    pre = root;
    traverse(root.right);
}
```

##### [965. 单值二叉树](https://leetcode.cn/problems/univalued-binary-tree/)

```java
/**
* 递归，计算中序遍历时，相邻两个节点的值
*/
TreeNode pre;
public boolean isUnivalTree(TreeNode root) {
    if (root == null) {
        return true;
    }
    boolean left = isUnivalTree(root.left);
    if (pre != null) {
        if (root.val != pre.val) {
            return false;
        }
    }
    pre = root;
    boolean right = isUnivalTree(root.right);
    return left && right;
}
```




#### 动态规划

##### [面试题 17.13. 恢复空格](https://leetcode.cn/problems/re-space-lcci/)

```java
/**
   * 状态定义：dp[i] 表示前 i 个未被识别的最少字符
   * 状态转移：
   * dp[i] = dp[i - 1] + 1 （如果字典中没有字符与之匹配）
   * dp[i] = Math.min(dp[i],dp[i - len]), len 代表字典中每个单词的不同长度
   * 返回值：最终返回 dp[sentence.length()] 代表在句子中未被识别的最少字符数
   * 初始条件：
   */
public int respace(String[] dictionary, String sentence) {
    int[] dp = new int[sentence.length() + 1];
    dp[0] = 0;
    for (int i = 1; i <= sentence.length(); i++) {
        dp[i] = dp[i - 1] + 1;
        for (String str : dictionary) {
            int len = str.length();
            if (i - len < 0) {
                continue;
            }
            if (sentence.substring(i - str.length(), i).equals(str)) {
                dp[i] = Math.min(dp[i], dp[i - str.length()]);
            }
        }
    }
    return dp[sentence.length()];
}
```





#### 备忘录

##### [139. 单词拆分](https://leetcode.cn/problems/word-break/)

```java
/**
   * 从 0 开始，每次遍历字典，看字典中的单词是否为字符串的前缀
   */
//memo[i] 代表0-i的字符串是否已经被匹配
private int[] memo;
public boolean wordBreak(String s, List<String> wordDict) {
    memo = new int[s.length()];
    Arrays.fill(memo, -1);
    return dp(s, 0, wordDict);
}

private boolean dp(String word, int startIndex, List<String> wordDict) {
    if (startIndex == word.length()) {
        return true;
    }
    //有备忘录则使用
    if (memo[startIndex] != -1) {
        return memo[startIndex] == 1;
    }
    //遍历所有字典，匹配 startIndex~len 的字符串，0-startIndex 的字符串已经匹配过
    for (String str : wordDict) {
        if (str.length() + startIndex > word.length()) {
            continue;
        }
        String subStr = word.substring(startIndex, startIndex + str.length());
        if (!subStr.equals(str)) {
            continue;
        }
        if (dp(word, startIndex + str.length(), wordDict)) {
            memo[startIndex] = 1;
            return true;
        }
    }

    memo[startIndex] = 0;
    return false;
}
```

#### 回溯法

##### [140. 单词拆分 II](https://leetcode.cn/problems/word-break-ii/)

```java
private List<String> list = new ArrayList<>();
public List<String> wordBreak(String s, List<String> wordDict) {
    backtrace(s, 0, wordDict, new StringBuilder());
    return list;
}

private void backtrace(String s, int startIndex, List<String> wordDic, StringBuilder trace) {
    if (startIndex == s.length()) {
        list.add(trace.toString().trim());
        return;
    }
    for (String word : wordDic) {
        int len = word.length();
        if (len + startIndex > s.length()) {
            continue;
        }

        String subStr = s.substring(startIndex, startIndex + len);
        if (!subStr.equals(word)) {
            continue;
        }
        trace.append(word).append(" ");
        backtrace(s, startIndex + len, wordDic, trace);
        //每次会多加一个空格，所以删除的时候要多删除一个字符
        trace.setLength(trace.length() - word.length() - 1);
    }
```

##### [面试题 17.15. 最长单词](https://leetcode.cn/problems/longest-word-lcci/)

```java
/**
   * 回溯法
   * 1. 先对字符串数组排序，长度从长到短，长度相同则按照字典序正序排列
   * 2. 回溯法：通过对一个字符从左到右的截取，该字符串能够由其他单词组成，如果可以，第一个返回的就是最长的单词，因为已经排好序了
   */
public String longestWord(String[] words) {
    List<String> list = Arrays.asList(words);
    list.sort((str1, str2) -> {
        if (str1.length() == str2.length()) {
            return str1.compareTo(str2);
        }
        return -(str1.length() - str2.length());
    });
    String res = "";
    for (String str : list) {
        //已经排好序了，第一个返回的结果一定是最长的
        if (dfs(str, 0, list)) return str;
    }
    return res;
}

/**
   * 在一个字符数组中找出一个长度最长的单词，该单词有数组中其他单词组成
   */
private boolean dfs(String word, int startIndex, List<String> wordList) {
    //找不到已经提早返回 false 了，能走到这里可以返回 true
    if (startIndex == word.length()) {
        return true;
    }
    //从左到右依次截取出 startIndex,word.length() 中的字串，判断是否能被拼接
    for (int i = startIndex; i < word.length(); i++) {
        //不需要和自己对比
        if (i - startIndex + 1 == word.length()) {
            continue;
        }
        String subStr = word.substring(startIndex, i + 1);
        if (!wordList.contains(subStr)) {
            continue;
        }
        //只要找到一种可能就可以返回 true
        if (dfs(word, i + 1, wordList)) {
            return true;
        }
    }
    return false;
}
```

##### [112. 路径总和](https://leetcode.cn/problems/path-sum/)


```java
    /**
     * 回溯：
     * 到达叶子节点时，判断剩余值是否和叶子节点值相同
     */
    private boolean isValid = false;

    public boolean hasPathSum(TreeNode root, int targetSum) {
        if (root == null) {
            return false;
        }
        backtrace(root, targetSum);
        return isValid;
    }

    private void backtrace(TreeNode root, int sum) {
        if (root == null) {
            return;
        }
        //剪枝：已经找到一种满足的情况，后续不需要在做判断
        if (isValid) {
            return;
        }
        if (root.left == null && root.right == null) {
            if (sum == root.val) {
                isValid = true;
            }
        }
        backtrace(root.left, sum - root.val);
        backtrace(root.right, sum - root.val);
    }
```





#### 数据结构

##### [208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)

```java
class Trie {
    //字典树结点
    class TrieNode {
        public HashMap<Character, TrieNode> dic = new HashMap<>();
        //记录当前结点是否为一个单词的最后一个字符
        public boolean isWord;
    }

    //根节点
    TrieNode root;

    public Trie() {
        //初始化根节点
        root = new TrieNode();
    }

    public void insert(String word) {
        TrieNode cur = root;
        //遍历插入字符串
        for (char ch : word.toCharArray()) {
            //如果当前结点找不到该字符，说明没有还未保存
            if (cur.dic.get(ch) == null) {
                //将当前字符保存至当前结点
                cur.dic.put(ch, new TrieNode());
            }
            //向下移动至下一个结点
            cur = cur.dic.get(ch);
        }
        //到一个单词结尾时，记录到该位置为一个完整的单词
        cur.isWord = true;
    }

    public boolean search(String word) {
        TrieNode cur = root;
        for (char ch : word.toCharArray()) {
            if (cur.dic.get(ch) == null) {
                return false;
            }
            cur = cur.dic.get(ch);
        }
        //判断当前结点是否为一个单词的结尾，如果是则返回
        return cur.isWord;
    }

    public boolean startsWith(String prefix) {
        TrieNode cur = root;
        for (char ch : prefix.toCharArray()) {
            if (cur.dic.get(ch) == null) {
                return false;
            }
            cur = cur.dic.get(ch);
        }
        //因为判断前缀，无需判断当前结点是否是前缀的最后一个字符，只要不跳出返回 false 即可返回 true
        return true;
    }
}
```

##### [211. 添加与搜索单词 - 数据结构设计](https://leetcode.cn/problems/design-add-and-search-words-data-structure/)

```java
class WordDictionary {
    class WordNode {
        public HashMap<Character, WordNode> dic = new HashMap<>();
        public boolean isWord;
    }

    WordNode root;

    public WordDictionary() {
        root = new WordNode();
    }

    public void addWord(String word) {
        WordNode cur = root;
        for (char ch : word.toCharArray()) {
            if (cur.dic.get(ch) == null) {
                cur.dic.put(ch, new WordNode());
            }
            cur = cur.dic.get(ch);
        }
        cur.isWord = true;
    }

    public boolean search(String word) {
        return dfs(word, 0, root);
    }

    public boolean dfs(String word, int start, WordNode cur) {
        if (start == word.length()) return cur.isWord;
        char ch = word.charAt(start);
        if (ch == '.') {
            for (Map.Entry<Character, WordNode> entry : cur.dic.entrySet()) {
                if(dfs(word, start + 1, entry.getValue())){
                    return true;
                }
            }
            return false;
        } else {
            if (cur.dic.get(ch) == null) {
                return false;
            }
            return dfs(word, start + 1, cur.dic.get(ch));
        }
    }
}
```

##### 并查集

```java
public class UnionFind {
    // 记录连通分量
    private int count;
    // 节点 x 的父节点是 parent[x]
    private int[] parent;

    /* 构造函数，n 为图的节点总数 */
    public UnionFind(int n) {
        this.count = n;
        parent = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }

    // 将节点 p 和节点 q 连通
    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ)
            return;
        parent[rootQ] = rootP;
        // 两个连通分量合并成一个连通分量
        count--;
    }

    // 判断节点 p 和节点 q 是否连通
    public boolean connected(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        return rootP == rootQ;
    }

    /* 返回当前的连通分量个数 */
    public int count() {
        return count;
    }

    /* 返回某个节点 x 的根节点 */
    public int find(int x) {
        if (parent[x] != x) {
            //路径压缩，使得各个 API 时间复杂度为 O(1)
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
}
```

#### 并查集

##### [1971. 寻找图中是否存在路径](https://leetcode.cn/problems/find-if-path-exists-in-graph/)

```java
/**
* 加入并查集，相连需要连接的点后，判断两个节点是否连接
*/
public boolean validPath(int n, int[][] edges, int source, int destination) {
    UnionFind unionFind = new UnionFind(n);
    for (int i = 0; i < edges.length; i++) {
        int pRoot = edges[i][0];
        int qRoot = edges[i][1];
        unionFind.union(pRoot, qRoot);
    }
    return unionFind.connected(source, destination);
}

class UnionFind {
    private int count;
    private int[] parent;

    public UnionFind(int n) {
        this.count = n;
        parent = new int[n];
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
        }
    }

    public void union(int p, int q) {
        int pRoot = find(p);
        int qRoot = find(q);
        if (pRoot == qRoot) {
            return;
        }
        parent[pRoot] = qRoot;
        count--;
    }

    public boolean connected(int p, int q) {
        int pRoot = find(p);
        int qRoot = find(q);
        return pRoot == qRoot;
    }

    public int find(int n) {
        if (parent[n] != n) {
            parent[n] = find(parent[n]);
        }
        return parent[n];
    }
}
```











#### 思路算法

[386. 字典序排数](https://leetcode.cn/problems/lexicographical-numbers/)

```java
/**
   * 遍历 n 次，每次试图将一个数字加入集合，初始数值 number 为 1，加入集合
   * 1. 当 number* 10 <= n，应该优先尝试将 number * 10 加入集合
   * 2. 当 number * 10 > n 时，直接将 number++ 后加入集合。
   * 特殊情况：number % 10 == 9 || number + 1 > n 时。number /= 10 直到不满足条件
   */
public List<Integer> lexicalOrder(int n) {
    List<Integer> res = new ArrayList<>();
    int number = 1;
    for (int i = 0; i < n; i++) {
        res.add(number);
        if (number * 10 <= n) {
            number = number * 10;
        } else {
            while (number + 1 > n || number % 10 == 9) {
                number /= 10;
            }
            number++;
        }
    }
    return res;
}
```
[792. 匹配子序列的单词数](https://leetcode.cn/problems/number-of-matching-subsequences/)

```java

/**
     * 初始化，构造 26 个桶，每个单词首字母相同的放入同一个桶中
     */
public int numMatchingSubseq(String s, String[] words) {
    //初始化 26 个桶
    ArrayList<Node>[] arr = new ArrayList[26];
    for (int i = 0; i < 26; i++) {
        arr[i] = new ArrayList<Node>();
    }

    //将首字母相同的放入同一个桶中
    for (String str : words) {
        char ch = str.charAt(0);
        arr[ch - 'a'].add(new Node(0, str));
    }

    int res = 0;
    //遍历字符串，找到该字符对应的桶
    for (char ch : s.toCharArray()) {
        ArrayList<Node> bucket = arr[ch - 'a'];
        arr[ch - 'a'] = new ArrayList<>();
        //遍历该桶内所有单词
        for (int i = 0; i < bucket.size(); i++) {
            Node node = bucket.get(i);
            //将该桶内所有单词的索引后移一位 index++，代表所有字符的 index 位及之前的字符已经成功匹配                
            node.index++;
            //当索引走完时，整个单词完全匹配
            if (node.index == node.word.length()) {
                res++;
            } else {
                //新索引的位置作为起始位置，看该索引后的字符是否能匹配，字符被分配到其他桶
                arr[node.word.charAt(node.index) - 'a'].add(node);
            }
        }
        //原有的桶清空
        bucket.clear();
    }
    return res;
}


class Node {
    int index;
    String word;

    public Node(int index, String word) {
        this.index = index;
        this.word = word;
    }
}
```

[1023. 驼峰式匹配](https://leetcode.cn/problems/camelcase-matching/)

```java

/**
     * 遍历字符串：
     * 当 index 走到了模式串的最后一位，字符串还有剩余的，剩余的有不是小写时直接返回 false
     * 当模式串和字符串在 index 处字符相等时，index++；不相等时且不为小写时直接返回 false
     */
public List<Boolean> camelMatch(String[] queries, String pattern) {
    List<Boolean> ans = new ArrayList<>(queries.length);
    for (String query : queries) {
        ans.add(isMatch(query, pattern));
    }
    return ans;
}

public Boolean isMatch(String query, String pattern) {
    int index = 0;
    for (char c : query.toCharArray()) {
        if (index == pattern.length()) {
            if (c < 'a' || c > 'z') {
                return false;
            }
        } else {
            if (c == pattern.charAt(index)) {
                index++;
            } else if (c < 'a' || c > 'z') {
                return false;
            }
        }
    }
    return index == pattern.length();
}
```



