# 第五章 Spring Web 起步

### 5.1 Spring MVC

Spring MVC 基于模型-视图-控制器模式实现 Web 应用程序。

模型层（Model）：负责处理业务逻辑 和数据操作

视图层（View）：负责格式化数据并呈现给用户

控制层（Controller）：负责接收、处理并转发请求，将响应结果发送给客户端

### 5.2 执行流程

每当用户在 Web 浏览器中点击链接或提交表单时，就开始一个请求。从发出请求到获取响应，中间经历好多过程。Spring MVC 执行流程如下：

1. 用户发起一个 HTTP 请求，请求被前端控制器 DispatcherServlet 接收；
2. DispatcherServlet 请求一个或多个处理器映射，返回一个执行链；
3. DispatcherServlet 将执行链返回的 Handler 发送给处理器适配器；

4. 处理器适配器根据 Handler 信息找到并执行相应的控制器；

5. 控制器执行完毕，返回 ModelAndView 对象，其中包括模型数据和视图信息；

6. 处理器适配器接收到 ModelAndView 对象，返回给 DispatcherServlet；
7. DispatcherServlet 接收到 ModelAndView 对象后，请求视图解析器解析视图；
8. 视图解析器根据接收到的视图信息匹配对应的视图结果，返回给 DispatcherServlet；
9. DispatcherServlet 接收到具体的视图后，填充模型数据渲染视图，生成最终的视图；
10. 视图通过响应结果返回给客户端。

![image-20211018130011705](05.Spring Web 起步.assets/image-20211018130011705.png)

### 5.3 Spring MVC 接口

- DispatcherServlet：所有的请求都要经过前端控制器统一分发，前端控制器相当于一个中央处理器，负责整个流程的执行，统一调度各个组件，降低组件之间的耦合。
- HandlerMapping：处理器映射根据请求的 URL 路径，通过注解或 XML 配置寻找匹配的控制器。
- HandlerAdapter：处理器适配器根据映射器找到的控制器信息，执行对应的控制器。
- Controller：控制器，也称为处理器，和 Java Servlet 起相同作用，执行请求的逻辑，将模型给数据和视图信息封装至 ModelAndView 对象并返回。
- ViewResolver：视图解析器根据视图信息将逻辑视图名解析为真正存在的视图。
- View：View 本身是一个接口，有不同的实现类支持不同的视图技术。

### 5.4 配置 Spring MVC

#### 5.4.1 配置 DispatcherServlet

Spring Web中有两种应用上下文，一种由 **DispatcherServlet** 启动时创建，加载配置文件或配置类中所声明的包含 Web 组件的 bean。另一种由 **ContextLoaderListener** 创建，加载应用中其他的 bean。
可以继承 AbstractAnnotationConfigDispatcherServletInitializer 类注册并初始化 DispatcherServlet 和 ContextLoaderListener。getServletConfigClasses() 方法声明一个配置类，配置 DispatcherServlet 创建的应用上下文中的 Web 组件 bean；getRootConfigClasses() 方法声明另一个配置类，配置 ContextLoaderListener 创建的应用上下文中的 bean；getServletMappings() 方法将一个或多个路径映射到 DispatcherServlet。

```java
public class ChatterWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {
    //指定 ContextLoaderListener 要加载的配置类
    @Override
    protected Class<?>[] getRootConfigClasses() {
        return new Class[]{RootConfig.class};
    }

    //指定 DispatcherServlet 要加载的配置类
    @Override
    protected Class<?>[] getServletConfigClasses() {
        return new Class[]{WebConfig.class};
    }

    //将 / 映射到 DispatcherServlet
    @Override
    protected String[] getServletMappings() {
        return new String[]{"/"};
    }
}
```
或者在 web.xml 文件中进行配置。\<param-name> 和 \<param-value> 键值对共有四种参数值可供使用。

| \<param-name>                  | 描述                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| contextClass                   | 实现了 ConfigurableWebApplicationContext 的类，默认为 XmlWebApplicationContext |
| contextConfigLocation          | 根据 contextClass 定义的应用上下文，读取配置文件（XmlWebApplicationContext）或配置类（AnnotationConfigWebApplicationContext） |
| namespace                      | WebApplicationContext 的命名空间，默认为 [servlet-name]-servlet |
| throwExceptionIfNoHandlerFound | 当找不到一个请求的控制器时是否抛出 NoHandlerFoundException，默认为 false |



```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
    <listener>
        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
    </listener>
    <!--ContextLoaderListener 加载的配置文件位置-->
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>/WEB-INF/root-context.xml</param-value>
    </context-param>

    <servlet>
        <servlet-name>dispatcherServlet</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <init-param>
            <!--DispatcherServlet 加载的配置文件位置-->
            <param-name>contextConfigLocation</param-name>
            <param-value>WEB-INF/dispatcherServlet-context.xml</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>dispatcherServlet</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
</web-app>
```

#### 5.4.2 配置其他  Servlet、Listener 和 Filter

也可以通过实现 WebApplicationInitializer 接口来注册和初始化任何 Servlet、Listener 和 Filter，分别调用ServletContext 的 addServlet()、addListener() 和 Filter() 方法。如下代码所示，先创建注解应用上下文，加载注册配置类，再创建并注册 DispatcherServlet，命名为 app，映射为根目录。

```java
public class ChatterWebAppInitializer implements WebApplicationInitializer {
    @Override
    public void onStartup(ServletContext servletContext) throws ServletException {
        //创建注解应用上下文，加载 Web 应用配置类
        AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();
        context.register(AppConfig.class);

        //创建并注册 DispatcherServlet
        DispatcherServlet servlet = new DispatcherServlet(context);
        ServletRegistration.Dynamic registration = servletContext.addServlet("app", servlet);
        registration.setLoadOnStartup(1);
        registration.addMapping("/");
    }
}
```
或使用 Xml应用上下文加载配置文件代替注解应用上下文。
```java
public class ChatterWebAppInitializer implements WebApplicationInitializer {
    @Override
    public void onStartup(ServletContext servletContext) throws ServletException {
        //创建Xml应用上下文，加载 Web配置文件
        XmlWebApplicationContext xmlContext = new XmlWebApplicationContext();
        xmlContext.setConfigLocation("/WEB-INF/root-context.xml");
......
```