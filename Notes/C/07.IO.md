# 第七章 IO

## 7.1 格式化 IO

### 7.1.1 格式化输出

**int printf(format, [arguments])** 函数中包括一个格式字符串和若干个参数。格式字符串中应包含每个参数的转换说明。转换说明由 % 和一个转换字符构成。若不添加修饰符，整型参数被转为 int 型，浮点型参数被转为 double 型，其默认精度为 6。

| 转换说明 | 输出                                             |
| -------- | ------------------------------------------------ |
| %a, %A   | p 或 P 记数法                                    |
| %c       | 字符                                             |
| %d, %i   | 有符号十进制整数                                 |
| %e, %E   | e 或 E 记数法                                    |
| %f       | 浮点数，十进制记数法                             |
| %g       | 根据不同的值，自动选择 %f 或 %e                  |
| %G       | 根据不同的值，自动选择 %f 或 %E                  |
| %o       | 无符号八进制整数                                 |
| %p       | 指针                                             |
| %s       | 字符串                                           |
| %u       | 无符号十进制整数                                 |
| %x, %X   | 无符号十六进制整数，10~15 分别用 a-f 或 A-F 表示 |
| %%       | 百分号                                           |

%g 和 %G 中自动选择规则：当指数小于 -4 或大于等于精度（默认为 6 ）时，用 %e 或 %E，否则用 %f。 

在转换说明的 % 和转换字符之间可以有序地加入若干个修饰符，进一步调整输出格式。

| 修饰符 | 含义                                                         |
| ------ | ------------------------------------------------------------ |
| 标记   | 五种标记（-, +, SP, #, 0）                                   |
| 数字   | 数字或字符串的最小长度。长度小于最小长度时用空格补足。例如 "%4d" |
| .数字  | 精度。                                                       |
| h      | 和整型一起使用，表示 short int 或 unsigned short int 类型。例如 "%hu", "%hd", "%hx", "%ho" |
| hh     | 和整型一起使用，表示 signed char 或 unsigned char 类型。例如 "%hhu", "%hhd", "%hhx" |
| j      | 和整型一起使用，表示 intmax_t 或 uintmax_t 类型。例如 "%jd", "%jx" |
| l      | 和整型一起使用，表示 long int 或 unsigned long int 类型。例如 "%lu", "%ld" |
| ll     | 和整型一起使用，表示 long long int 或 unsigned long long int 类型。例如 "%llu", "%lld" |
| L      | 和浮点型一起使用，表示 long double 类型。例如 "%Le", "%Lf"   |
| t      | 和整型一起使用，表示 ptrdiff_t 类型，即两个指针的差值。例如 "%td" |
| z      | 和整型一起使用，表示 sizeof() 返回的类型。例如 "%zd"         |

".数字" 调整精度，遵循如下规则：

- 对于 %e, %E, %f，表示小数点右边的最大位数，即精度只针对小数部分，不包括整数部分
- 对于 %g, %G，表示有效数字的最大位数，即精度针对整数和小数部分
- 对于 %s，表示字符串的最大长度
- 对于整型转换说明，表示整数的最小长度。若整数长度小于最小长度，用 0 补足

| 标记 | 含义                                         |
| ---- | -------------------------------------------- |
| -    | 左对齐打印                                   |
| +    | 显示符号值（+ 或 -）                         |
| SP   | 显示符号值，若为 +，空格代替；- 保持原样输出 |
| #    | 将结果转换为另一种形式。                     |
| 0    | 用 0 代替空格补足                            |

\# 转换结果时遵循如下规则：

- 对于 %o, %x, %X，# 会在八进制数字加上前缀 0，在十六进制数字加上 0x 或 0X 前缀，例如 "#%#o"
- 对于浮点型，保证无论如何一定会输出一个小数点

ptintf() 函数进行格式化输出的本质是读取内存中的二进制数，根据转换说明翻译成指定类型的数据。

若输出成功，printf() 函数返回输出的字符个数，包括换行等不可见字符；若输出失败，返回一个负值。

### 7.1.2 格式化输入

**int scanf(format, [*arguments])** 函数包括一个格式字符串和若干个指针参数。若不添加修饰符，整数存储到 int 型参数中，浮点数存储到 float 型参数中。

| 转换说明       | 输入               |
| -------------- | ------------------ |
| %c             | 字符               |
| %e, %f, %g, %a | 浮点数             |
| %E, %F, %G, %A | 浮点数             |
| %i, %d         | 有符号十进制整数   |
| %o             | 有符号八进制整数   |
| %p             | 指针               |
| %s             | 字符串             |
| %u             | 无符号十进制整数   |
| %x, %X         | 有符号十六进制整数 |
| %%             | 百分号             |

| 修饰符 | 含义                                                         |
| ------ | ------------------------------------------------------------ |
| 数字   | 一次读取的最大读取长度                                       |
| hh     | 把整数作为 signed char 或 unsigned char 类型读取，例如 "%hhd", "%hhu" |
| ll     | 把整数作为 long long 或 unsigned long long 类型读取，例如 "%lld", "%llu" |
| h      | 把整数作为 short int 或 unsigned short int 类型读取，例如 "%hd", "%hu" |
| l      | 把整数作为 long 或 unsigned 类型读取，或把浮点数作为 double 类型读取 |
| L      | 把浮点数作为 long double 类型读取                            |
| j      | 把整型作为 intmax_t 或 uintmax_t 类型读取，例如 "%jd", "%jo" |
| z      | 把整型作为 sizeof() 返回的类型读取，例如 "%zd"               |
| t      | 把整型作为  ptrdiff_t 类型读取                               |

scanf() 函数逐个读取输入字符串中的字符。

- 对于整型、浮点型转换说明，忽略空格、制表和换行符等空白符，直到满足最大读取长度或遇到不可转换的字符时才停止读取。
- 对于 “%s” 字符串转换说明，忽略空格、制表和换行符等空白符，直到满足最大读取长度或遇到空白符时才停止读取。
- 对于 “%c” ，只读取第一个字符；对于 " %c"，只读取第一个非空字符。

第二次读取的起点字符为第一次读取终点的下一个字符。第一次读取出错后停止读取输入。

scanf() 函数返回成功匹配的项数。读取出错，没有读取任何项时返回 0；读取到文件末尾时返回 EOF。

**\* 修饰符**

printf() 函数中 \* 用于指定可变的最小长度和精度，必须给 \* 传入一个 int 型整数。

```c
int num1 = 100;
//指定最小输出长度为 5
printf("%*d", 5, num1);

float num2 = 123.45;
//指定最小输出长度为 10，精度为 1
printf("%*.*f",10,1,num2);
```

scanf() 函数中 \* 用于跳过当前匹配结果，不把当前匹配结果存储到参数中。

```c
int n;
//跳过第一次和第二次匹配结果，第三次匹配结果存储到参数中
scanf("%*d %*d %d",&n);
```

## 7.2 单字符 IO

getchar() 和 putchar 分别输入和输出单个字符。

## 7.3 字符串 IO

### 7.3.1 字符串输入

**char *gets(char *str)** 函数读取字符串，直到遇到换行符（会丢弃换行符）。但是 gets() 函数无法得到字符串的长度。若读取的字符串长度超过分配的内存空间，超出的字符将溢出占据其他内存空间，可能导致数据被擦除。因此在 C11 标准中废除了 不安全的gets() 函数。

**char *fgets(char * str, int count, FILE * stream)** 函数通过第 2 个参数来限制输入的字符数。若设置单次读取的最大字符数为 count，本次读取将在读到 count - 1 个字符或遇到第一个换行符（会保留换行符）时停止，剩余的字符仍然留在缓冲区等待下一次读取。 

**char *gets_s(char * str, rsize_t n)** 函数和 fgets() 函数类似，但只从标准输入中读取数据，所以不需要第 3 个参数。若设置单次读取的最大字符数为 count，本次读取将在读到 count - 1 个字符或遇到第一个换行符（会丢弃换行符）时停止，剩余的字符被清空，缓冲区被清空。

gets(), fgets(), gets_s() 函数读取成功时返回传入的 char 型指针，读取失败或读到文件末尾时返回 NULL 空指针（数字 0）。

```c
char words[5]; //分配的内存空间

gets(words); //缓冲区：1234567\n，输入：1234567
printf("%s",words); //输出：1234567

fgets(words,5,stdin); //缓冲区：1234567\n，输入：1234
printf("%s",words); //输出：1234
fgets(words,5,stdin); //从缓冲区中获取剩余字符：567\n
printf("%s",words); //输出：567\n

gets_s(words,5); //缓冲区：1234567\n，输入：1234
printf("%s",words); //输出：1234
gets_s(words,5);  //缓冲区：\0，缓冲区被清空，再次输入：567\n
printf("%s",words); //输出：567\n
```

### 7.3.2 字符串输出

**int puts(const char * str)** 函数读取字符串，直到遇到空字符标记（丢弃空字符标记）。在读取的字符串后添加一个换行符并打印。

**int fputs(const char * str, FILE * stream)** 函数也是遇到空字符标记（丢弃空字符标记）才停止读取。但不会在读取的字符串后加额外的换行符。

通常 puts() 和 gets() 搭配使用，fputs() 和 fgets() 搭配使用。

```c
char words[5]; //缓冲区

gets(words); //缓冲区：123\n，输入：123
//puts() 函数会额外加一个换行符
puts(words); //输出：123，实际输出：123\n

fgets(words,5,stdin); //缓冲区：123\n，输入：123\n
//fputs() 函数不会额外加一个换行符
fputs(words,stdout); //输出：123\n，实际输出：123\n
```

### 7.3.3 缓冲区

输入的内容直接发送给程序，称为无缓冲输入。

输入的内容放在临时的缓冲区中，当结束输入后，缓冲区中的内容发送给程序，称为缓冲输入。大多数系统都使用缓冲输入，缓冲区的大小由系统决定，常见是 512 字节和 4096 字节。缓冲输入分为完全缓冲和行缓冲。

完全缓冲是当缓冲区被填满时才刷新缓冲区（缓冲区中的内容发送给程序）。文件输入输出一般是完全缓冲。

行缓冲是遇到换行符时刷新缓冲区。键盘输入一般是行缓冲，当用户按下回车键后刷新缓冲区。

## 7.4 文件

不同的操作系统对文件的换行符、文件结尾等有不同的定义。

- Linux, UNIX 使用 \n 表示换行符，使用记录文件大小的方式决定文件结尾；

- Macintosh 使用 \r 表示换行符，使用记录文件大小的方式决定结尾；

- Windows 使用 \r\n 表示换行符，使用 Ctrl + Z 表示文件结尾。

C 把文件看作连续的字节，并提供了两种访问文件的模式：二进制模式和文本模式。二进制模式逐个字节读取文件；文本模式逐个字节读取文件后，将字节转换为字符，并把 \r\n 等换行符映射为 \n。

### 7.4.1 标准 IO 过程

C 提供了标准 I/O 包，即用于处理文件的标准模型，开发者使用标准 I/O 包可以处理不同系统上的文件。至于如何根据不同的系统差异处理文件，由具体的编译器解决。标准 IO 过程如下：

- 调用 fopen() 函数打开文件，创建缓冲区，创建一个包含文件和缓冲区数据的结构，并返回指向该结构的指针，即文件指针。C 程序会自动打开三个文件：标准输入、标准输入和标准错误输出，它们对应的文件指针分别为 stdin, stdout, stderr。
- 调用输入函数，文件中的数据块被拷贝到缓冲区，并不断发送给程序，直到文件结尾。调用输出函数同理。
- 调用 fclose() 函数关闭文件。刷新输出缓冲区中的剩余内容，丢弃输入缓冲区中的剩余内容。

### 7.4.2 文件 IO

**FILE *fopen( const char *restrict filename, const char *restrict mode )** 函数传入一个文件名和处理模式，返回该文件的文件指针。处理模式指定如何打开文件，"r", "w", "a", "r+", "w+", "a+" 模式都是以文本文件模式打开文件。加上 "b" 后以二进制模式打开文件。

| 模式               | 含义                 | 文件已存在           | 文件不存在 |
| ------------------ | -------------------- | -------------------- | ---------- |
| "r"                | 以只读模式打开文件   | 从头开始读取文件     | 无法打开   |
| "w"                | 以只写模式打开文件   | 删除原文件内容       | 创建新文件 |
| "a"                | 以追加模式打开文件   | 追加到原文件内容末尾 | 创建新文件 |
| "r+"               | 以读写模式打开文件   | 从头开始读写文件     | 报错       |
| "w+"               | 以读写模式打开文件   | 删除原文件内容       | 创建新文件 |
| "a+"               | 以读写模式打开文件   | 追加到原文件内容末尾 | 创建新文件 |
| "rb",“wb","ab+"... | 以二进制模式打开文件 |                      |            |

**int fclose( FILE \*stream )** 函数关闭文件指针指定的文件。

**int getc( FILE \*stream )** 函数从指定文件获取一个字符。

**int putc( int ch, FILE \*stream )** 函数输出一个字符到指定文件。

**int fprintf( FILE *restrict stream, const char *restrict format, ... )** 函数将格式化输出到指定文件。

**int fscanf( FILE *restrict stream, const char *restrict format, ... )** 函数将格式化输入到指定文件。

**char *fgets(char * str, int count, FILE * stream)** 函数从指定文件获取指定个数字符，存储到指定 char 数组中。

**int fputs(const char * str, FILE * stream)** 函数指定字符串存储到指定文件中。

**int fseek( FILE *stream, long offset, int origin )** 函数定位到文件指定位置。

```c
fseek(fp,0L,SEEK_SET); //定位至文件开始处
fseek(fp, 2L, SEEK_CUR); //定位至文件当前位置前移2个字节
fseek(fp, 0L, SEEK_END); //定位至文件结尾处
```

**long ftell( FILE *stream )** 函数返回文件当前位置。以二进制模式打开时，文件中第一个字节位置为 0。以文本文件模式打开时返回值不确定。

**int fflush( FILE *stream )** 函数将输出缓冲区中的内容发送到指定文件。

**int setvbuf( FILE *restrict stream, char *restrict buffer, int mode, size_t size)** 函数可以为指定文件 IO 设置缓冲区，更改缓冲类型。

**size_t fread( void *restrict buffer, size_t size, size_t count, FILE *restrict stream )** 函数以二进制模式从文件中读取数据。

**size_t fwrite( const void *restrict buffer, size_t size, size_t count, FILE *restrict stream )** 函数将二进制数据写入文件。

返回 EOF 表明到达文件结尾或读写错误，以下两个函数可以进一步区分：

**int feof( FILE *stream )** 函数当检测到文件结尾时，返回非零值。

**int ferror( FILE *stream )** 函数当读写出现错误时，返回非零值。
