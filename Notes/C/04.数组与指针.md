# 第四章 数组与指针

## 4.1 数组

### 4.1.1 声明

数组是有限个相同数据类型元素构成的集合。声明数组时，必须指定数组大小和元素类型。数组大小必须为整型且大于 0。

```c
float candy[365]; //可以存放 365 个 float 类型元素的数组
char arr[1.5]; //不可以
int num[-2]; //不可以
```

### 4.1.2 初始化

若声明数组的同时没有初始化数组，数组中存储着垃圾值（数组所处内存地址上现有的值）；若声明并初始化数组，数组存储初始化值。若初始化值个数少于数组长度，数组剩余的未被初始化的元素被初始化为0；若初始化个数多余数组长度，编译器发出警告并丢弃多余的初始化值。

```c
int powers[4]; //声明未初始化，数组存储着随机的垃圾值
int powers[4] = {1,2,3,4}; //声明并初始化
int powers[4] = {1,2}; //部分初始化，剩余元素初始化为 0
int powers[4] = {1,2,3,4,5}; //初始化，丢弃超出数组长度的初始化值
int powers[] = {1,2,3}; //不指定数组长度，编译器根据初始化值个数决定数组长度
```

**初始化器**

C99 的初始化器可以初始化数组中指定索引的元素值。

```c
int arr[6] = {0,0,0,0,0,100}; //传统的初始化语法
int arr[6] = {[5] = 100}; //初始化器初始化 arr[5] 为 100
```

初始化从左到右进行，后面的初始化结果可以覆盖前面的初始化结果；初始化器后面的值被用于初始化器后面的元素，例如 arr[4] = 40, 50, 60 中，50 用于初始化 arr[5]，60 用于初始化 arr[6]。

```c
int arr[6] = {10,20,arr[4] = 40,50,arr[1] = 100}; //初始化结果：[100, 20, 0, 40, 50, 0]
```

### 4.1.3 长度

声明数组时用 const 修饰将数组设为只读状态，数组内容不能被修改。sizeof 获取数组或数组元素的大小。C 编译器不会检查索引是否越界，使用越界的索引会产生不可预料的结果。

```c
const int array[2] = {1,2};
array[1] = 3;//报错，不能修改数组内容

sizeof(array); //数组共有 2 个元素，共占据 8 个字节
sizeof(array[1]); //int 类型元素占据 4 个字节
```

### 4.1.4 赋值

C 不允许把一个数组赋值给另一个数组，也不允许声明数组和初始化数组不在同一语句中。

```c
int a[5] = {1,2,3};
int b[5];
b[5] = {1,2,3,4,5}; //不允许
b = a; //不允许
```

## 4.2 指针

### 4.2.1 声明

指针是一个值为内存地址的变量。用 \* 声明指针类型。指针只能存储同类型变量的内存地址，或者说指针只能指向同类型的变量。例如 int 类型的指针只能存储 int 类型变量的内存地址。

```c
int * pt; //指针 pt 指向 int 类型变量
int ** pt; //指针 pt 指向 int 类型指针
int * pt[2]; //数组 pt 有两个元素，两个元素都是 int 类型指针
int (* pt)[2]; //指针 pt 指向二维数组，每个数组都有两个 int 类型元素
```

### 4.2.2 指针操作

**赋值**

& 运算符给出变量的内存地址，通常用无符号十六进制整数表示。

```c
long num1 = 5;
long num2 = 10;
&num1; //获取 long 类型变量的内存地址

printf("%p %p\n", &num1, &num2); //0x7ffc04829a88 0x7ffc04829a80
```

& 运算符获取变量的内存地址可以赋值给同类型指针。数组名或指针也可以给另一个同类型的指针赋值。

```c
int num = 5;
int arr[2] = {1,2};
int * ptr1, * ptr2, * ptr3;

ptr1 = &num; //获取变量内存地址，赋值给同类型指针
ptr2 = arr; //数组名赋值给同类型指针
ptr3 = ptr1; //两个指针都指向 int 类型变量

printf("%p %p %p",ptr1,ptr2,ptr3);//0x7fffbd4c7384 0x7fffbd4c7370 0x7fffbd4c7384
```

**解引用**

\* 运算符除了定义指针，还可以解引用指针，即获取指针所指向的变量的值。

```c
int num1 = 1; //int 类型变量
int * ptr; //指向 int 类型变量的指针
ptr = &num1; //获取 int 类型变量 num1 的内存地址，存储在指针 ptr 中
*ptr; //获取指针 ptr 指向的变量 num1 的值

printf("%p %d",ptr,*ptr);//0x7ffc4552a3d4 1
```
虽然指针存储的内存地址为无符号十六进制整数，但不可把指针认为是整数类型。一般处理整数的操作也不能用来处理指针。例如可以将两个整数相乘，但不能将两个指针相乘。

声明指针后应进行初始化。若未初始化指针，系统不会分配内存空间给指针。如下未初始化的指针 pt，此时给解引用指针 \*pt 赋值 5，但指针还未分配存储空间，所以不知道将数据 5 放在何处。可能导致数据擦除等严重问题。

```c
int * pt; //未初始化的指针
*pt =5; //严重的错误
```

**取址**

和其他变量一样，指针也有自己的内存地址和值。& 运算符可以获取指针自身的地址。

```c
int num = 1;
int * ptr = &num;
*ptr; //指针 ptr 所指向变量的值
ptr; //指针 ptr 所指向变量的内存地址
&ptr; //指针自身的内存地址

printf("%d %p %p",*ptr,ptr,&ptr);//1 0x7ffedefa8d4c 0x7ffedefa8d40
```

**指针与整数相加**

指针与整数 n 相加的结果是指针相对于初始地址，偏移了 n*m 个字节（m 为指针类型所占据的字节数）。

```c
int * ptr1, * ptr2;
ptr2 = ptr1 + 3;// ptr1 为int 类型，占据 4 个字节。ptr1 + 3 结果是指针相对于初始位置偏移了 4 * 3 = 12 个字节

printf("%p %p",ptr1,ptr2);//0x7fff49f89460 0x7fff49f8946c
```

**递增**
指针递增的结果和指针与整数 1 相加的结果相同。

```c
int * ptr1, * ptr2;
ptr2 = ptr1 + 1;
ptr1++;

printf("%d",ptr2 == ptr1);//1
```

**指针减去一个整数**

指针减去一个整数的结果和指针加上一个整数结果类似，区别在于指针减去一个整数后的地址小于初始地址，但指针加上一个整数后的地址大于初始地址。

```c
int * ptr1, * ptr2;
ptr2 = ptr1 - 3;// ptr1 为int 类型，占据 4 个字节。ptr1 - 3 结果是指针相对于初始位置偏移了 4 * 3 = 12 个字节

printf("%p %p",ptr1,ptr2);//0x7ffd4110a2c0 0x7ffd4110a2b4
```

**递减**

指针递减的结果和指针减去整数 1的结果相同。

```c
int * ptr1, * ptr2;
ptr2 = ptr1 - 1;
ptr1--;

printf("%d",ptr2 == ptr1);//1
```

**求差**

两个同类型的指针求差返回 ptrdiff_t 类型。ptrdiff_t 类型是一个整数值，等于两个指针相差的字节数除以指针类型所占据的字节数。

```c
int * ptr1, * ptr2, *ptr3;
ptr2 = ptr1 + 3; //ptr2 和 ptr1 相差 12 字节
ptr3 = ptr2 - ptr1; //12 / 4 = 3

printf("%td",ptr3);//3
```

 **比较**

指针可以比较大小，但比较两个变量的指针大小通常是没有意义的。

## 4.3 数组与指针

数组名是一个指针，保存着数组首元素的内存地址。解引用数组名可以获得首元素保存的值。

```c
char ch[4]; 
ch == &ch[0]; //数组名 ch 是指向首元素 ch[0] 的指针
*ch == ch[0]; //解引用数组名获取首元素的值
ch[i] = *(ch + i);
```

n 维数组中解引用 1 ~ n-1 次得到地址值，解引用 n 次得到变量值。

```c
char ch[4][3];
ch == &ch[0];
ch[0] == &ch[0][0]; //ch[0] 保存着 ch[0][0] 的地址值
*ch == ch[0]; //解引用 1 次得到地址值
**ch == *ch[0] == ch[0][0]; //解引用 2 次得到变量值
ch[m][n] = *(*(ch + m) + n);
```

**数组名与指针的区别**

数组名是指向首元素的指针，但其保存的内存地址不能更改。数组名相当于一个 const 修饰的指针。

指针保存的内存地址可以更改。

```c
char arr[5]; //等价于 char * const ptr;
&arr; //允许
arr + 1; //允许
++arr; //不允许改变数组名所存储的地址值

char * ptr;
&ptr; //允许
ptr + 1; //允许
++ptr; //允许
```

在函数原型中可以省略形参名，下面四种函数原型是等价的：

```c
int sum(int * ar, int n);
int sum(int *, int);
int sum(int ar[], int n);
int sum(int [], int);
```

在函数定义中不可以省略形参名，下面两种函数定义是等价的：

```c
int sum(int * ar, int n){}
int sum(int ar[], int n){}
```

指针与整数 n 相加的结果是指针相对于当前元素，往后移动了 n 个元素。若相加的结果超出了数组长度，指针移动到指定位置后会得到随机的垃圾值。指针自增的结果是指针相对于当前元素，移动到后一个元素。

同理可得指针减去整数 n 的结果是指针相对于当前元素，往前移动了 n 个元素。指针自减的结果是指针相对于当前元素，移动到前一个元素。

```c
int arr[3] = {1,2,3};
int * ptr1;

ptr1 = &arr[1]; //指针指向第二个元素
ptr1 = ptr1 + 1; //指针往后移动 1 个元素，指向第三个元素
printf("%d",*ptr1); //第三个元素值为：3

ptr1 = &arr[1] + 4; //指针往后移动 4 个元素，超出数组长度
printf("%d",*ptr1);//随机的垃圾值：32767
```

对两个指针求差的结果是两个元素索引的差。

```c
int arr[4] = {1,2,3,4};
int * ptr1, * ptr2;

ptr1 = &arr[1];
ptr2 = &arr[3];

printf("%td",ptr2 - ptr1); //2
```

比较两个指针的结果是确定两个指针指向元素的先后顺序。数组中越靠前的元素，其指针越小。

```c
int arr[4] = {1,2,3,4};
int * ptr1, * ptr2;

ptr1 = &arr[0]; 
ptr2 = &arr[3];

/*第 4 个元素的内存地址大于第 1 个元素*/
printf("%d",ptr2 > ptr1); //1
```

解引用与自增或自减一起使用的情况：

**\*p++**：\* 和 ++ 是同一优先级，根据结合律是从右到左运算。先计算 p++，再计算 \*p。但因为后缀 ++ 代表先使用后自增，所以最终结果是先计算 \*p，然后计算 p++。

**\*++p**：先计算 ++p，再计算 \*p。

**++\*p**：先计算 \*p，再计算 ++p。

**(\*p)++**：先计算 \*p，然后将 p 指针所指向的变量值加一，p 指针没有发生变化。

**\*(p++)**：结果和 \*p++ 相同。
