# 第六章 内存管理

运行中的程序指令和程序所需的数据都存储在内存中。

## 6.1 作用域

作用域指定程序对数据的访问权限，即对变量和函数的访问权限。

C 中变量作用域分为：块作用域、函数原型作用域、函数作用域和文件作用域。

- 块作用域：用一对 { } 括起来的代码区域，还包括 for, while 等控制语句 ( ) 括住的范围和函数定义中的形参。在块作用域中声明的变量只能在当前块作用域中使用。

```c
for(int i =0; i < 5; i++){
    int var = 20;
}

int a = var; //报错，var 未定义
int b = i; //报错，i 未定义
```

- 函数作用域：在函数中定义的所有 goto 语句标签只能在此函数中使用。函数作用域仅用于 goto 语句的标签。

```c
int main(void){
    label1:{      
        //一些语句
    }
    
    label2:{
        goto label1;
    }
}
```

- 函数原型作用域：在函数原型中定义的变量只在当前函数原型 ( ) 中使用，函数原型通常不提供变量名。

```c
int mighty(int mouse, double large);

int a = mouse; //报错，mouse 未定义
```

- 文件作用域：定义在函数外部的变量，可以被当前程序文件中的其他函数或其他程序文件使用。

```c
#include <stdio.h>

int a; //外部链接，可以被其他程序文件使用 
static int b; //内部链接，只能在当前程序文件中使用

int main(void){
     return 0;
}
```

## 6.2 链接

当前 C 源码文件和其包含的若干个头文件在编译后视为一个单独文件，称为翻译单元。一个简单的程序可以由一个翻译单元组成，复杂的程序通常由若干个翻译单元组成。

链接指定变量是否可以被其他翻译单元使用，无链接和内部链接变量只能在当前翻译单元使用，外部链接变量可以在若干个翻译单元之间共享使用。

C 中有三种链接：外部链接、内部链接和无链接。

- 无链接： 块作用域、函数作用域和函数原型作用域内的变量都是无链接变量。
- 内部链接：若文件作用域变量是内部链接，则该变量只能在当前翻译单元使用。
- 外部链接：若文件作用域变量是外部链接，该变量可以在若干个翻译单元之间共享使用。

```c
int num1 = 5; //文件作用域变量，外部链接
static int num2 = 5; //文件作用域变量，内部链接

int main(void){
    return 0;
}
```

## 6.3 存储期

存储期指定程序的数据在内存中保留的时间。C 有四种存储期：静态存储期，线程存储期、自动存储期和动态分配存储期。

- 静态存储期：在程序开始执行时给变量分配内存，直到程序运行结束。文件作用域变量一定是静态存储期，块作用域可能是静态存储期。
- 线程存储期：当程序执行被分为多个线程时，线程开始时给变量分配内存，直到线程结束。
- 自动存储期：当进入到变量作用域时，给变量分配内存，离开作用域时释放内存。块作用域变量通常都是自动存储期。
- 动态分配存储期：调用 malloc() 等函数时给变量分配内存，调用 free() 等函数时释放内存。

## 6.4存储类别

存储期、作用域和链接的不同组合方式构成不同的存储类别。常见的五种存储类别：自动、寄存器、静态外部链、静态内部链接、静态无链接和动态分配。

- 自动：默认情况下，声明在块或函数定义中的任何变量都属于自动存储类别，也可用 auto 关键字显式声明自动变量 。具有自动存储期、块作用域和无链接。如果未初始化自动变量，它的值为垃圾值。

```c
itn main(void){
    auto int num;
      
    return 0;
}
```

- 寄存器：在块中用 register 显式声明寄存器变量，目的是请求编译器将此变量存储到访问速度最快的区域中，但是无法获取其内存地址。具有自动存储期、块作用域和无链接。如果未初始化寄存器存储类别变量，它的值为垃圾值。

```c
{
    int normal = 10; //自动变量
    register int quick = 20; //寄存器变量
}
```

- 静态无链接：在块中用 static 声明的变量属于静态无链接变量。具有静态存储期、块作用域和无链接。在离开块作用域后，该变量不会销毁。只在编译时被初始化一次。如果未初始化，所有字节设置为 0 。不能在函数的形参中使用 static。

```c
{
    int auto_var = 10; //自动变量
    register register_var = 10; //寄存器变量
    static int static_var = 10; //静态变量
}

int no(static int flu); //不允许
```

- 静态外部链接：没有用 static 声明的文件作用域变量属于静态外部链接变量。具有静态存储期、文件作用域和外部链接。只在编译时被初始化一次。如果未初始化，所有字节设置为 0 。

```c
int extern_var;

int main(void){
    extern int extern_var; //引用了当前翻译单元的变量
    return 0;
}
```

若要使用其他翻译单元中的静态外部链接变量，应使用 extern 表示引用了该变量。

```c
extern int extern_var; //引用了其他翻译单元的变量

void func(int num){
    //一些语句
}
```

- 静态内部链接：用 static 声明的文件作用域变量属于静态内部链接变量。具有静态存储期、文件作用域和内部链接。只在编译时被初始化一次。如果未初始化，所有字节设置为 0 。

```c
static int num1; //静态内部链接变量
int num2; //静态外部链接变量

int main(void){
    extern int num2; //可选的重复引用声明
}
```

- 动态分配：动态分配的内存由 malloc() 等函数分配，传入所需的内存字节数，返回一个指向分配好的内存块首字节的 void 类型指针。void 指针可以被强制转型为其他类型指针。free() 函数以 malloc() 函数返回的指针为参数，释放该内存。

```c
double * ptd1;
double * ptd2;
ptd1 = (double *)malloc(30*sizeof(double)); //malloc() 不会进行初始化
ptd2 = (double *)calloc(30,sizeof(double)); //calloc() 将所有位初始化为 0 
//一些语句
free(ptd1);
free(ptd2);
```

当在一个文件中声明各种存储类别的同名变量后，内层的作用域变量会将外层作用域变量隐藏。

```c
int m = 10; //静态外部链接变量

{
    int m = 5;
    printf("%d",m); //5，隐藏了外层的静态外部链接变量

    {
        int m = 10;
        printf("%d",m); //10，隐藏了外层自动变量
    }
    printf("%d",m); //5，出了内层作用域，内层变量销毁
}
```

函数也有存储类别，分为外部函数、静态函数和内联函数。

```c
double func1(void); //默认的外部函数，可以被其他文件的函数访问
static double func2(void); //静态函数，只能用于当前文件
extern double func3(void); //当前文件引用了其他文件的 func3() 外部函数
```

## 6.5类型限定符

const 限定符限定的数据不能被修改。参见 [函数](03.函数)。

volatile 限定符限定的数据除了被当前程序修改外，还可以被其他进程修改。该限定符的目的是为了告诉编译器数据能被其他进程修改，不要进行默认的优化。

restrict 限定符限定的指针是访问它所指向数据的唯一且初始的方式。该限定符的目的是为了告诉编译器该数据只能被当前指针修改，方便编译器选择优化方案。

\_Atomic 限定符限定当一个线程对一个原子类型的变量进行原子操作时，其他线程不能访问该变量。
