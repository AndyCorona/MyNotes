### CPU

![img](Linux 调优.assets/1e66612e0022cd6c17847f3ab6989007.png)

![img](Linux 调优.assets/596397e1d6335d2990f70427ad4b14ec.png)

![img](Linux 调优.assets/b0c67a7196f5ca4cc58f14f959a364ca.png)

![img](Linux 调优.assets/7a445960a4bc0a58a02e1bc75648aa17.png)

### 内存

**1. 伙伴关系**

在操作系统分配内存的过程中，一个内存块常常被分成两个大小相等的内存块，这两个大小相等的内存块就处于伙伴关系。它满足 3 个条件 ：

-   两个块具有相同大小记为 2^K
-   它们的物理地址是连续的
-   从同一个大块中拆分出来

**2. 伙伴算法的实现原理**

为了便于页面的维护，将多个页面组成内存块，每个内存块都有 2 的方幂个页，方幂的指数被称为阶 order。order相同的内存块被组织到一个空闲链表中。伙伴系统基于2的方幂来申请释放内存页。
当申请内存页时，伙伴系统首先检查与申请大小相同的内存块链表中，检看是否有空闲页，如果有就将其分配出去，并将其从链表中删除，否则就检查上一级，即大小为申请大小的2倍的内存块空闲链表，如果该链表有空闲内存，就将其分配出去，同时将剩余的一部分（即未分配出去的一半）加入到下一级空闲链表中；如果这一级仍没有空闲内存；就检查它的上一级，依次类推，直到分配成功或者彻底失败，在成功时还要按照伙伴系统的要求，将未分配的内存块进行划分并加入到相应的空闲内存块链表在释放内存页时，会检查其伙伴是否也是空闲的，如果是就将它和它的伙伴合并为更大的空闲内存块，该检查会递归进行，直到发现伙伴正在被使用或者已经合并成了最大的内存块。

slab分配器分配内存以字节为单位，基于伙伴分配器的大内存进一步细分成小内存分配。换句话说，slab 分配器仍然从 Buddy 分配器中申请内存，之后自己对申请来的内存细分管理。对小块内存（小于 128K），C 标准库使用 **brk()** 来分配，也就是通过移动堆顶的位置来分配 内存。这些内存释放后并不会立刻归还系统，而是被缓存起来，这样就可以重复使用。而大块内存（大于 128K），则直接使用内存映射 **mmap()** 来分配，也就是在文件映射段找一 块空闲内存分配出去。![img](Linux 调优.assets/e28cf90f0b137574bca170984d1e6736.png)

![img](Linux 调优.assets/8f477035fc4348a1f80bde3117a7dfed.png)

![img](Linux 调优.assets/52bb55fba133401889206d02c224769b.png)

![img](Linux 调优.assets/d79cd017f0c90b84a36e70a3c5dccffe.png)

### IO

![img](Linux 调优.assets/b6d67150e471e1340a6f3c3dc3ba0120.png)

![img](Linux 调优.assets/6f26fa18a73458764fcda00212006698.png)

![img](Linux 调优.assets/ee11664d015f034e4042b9fa4fyycff3.jpg)

![img](Linux 调优.assets/1802a35475ee2755fb45aec55ed2d98a.png)

### 网络

![img](Linux 调优.assets/37d04c213acfa650bd7467e3000356a4.png)

![img](Linux 调优.assets/b07ea76a8737ed93395736795ede44e0.png)

![img](Linux 调优.assets/5dde213baffd7811ab73c82883b2a75d.png)

**Linux 性能测试工具**

![img](Linux 调优.assets/9ee6c1c5d88b0468af1a3280865a6b7a.png)

**基准测试工具**

![img](Linux 调优.assets/f094f489049602e1058e02edc708e6e9.png)

